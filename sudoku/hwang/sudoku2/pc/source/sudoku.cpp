/*************************************************************************/

/* comments

The language in which this file is written is gen_gen_C, which may
be compiled with any C compiler, but also is parsed and written by
gen_gen. DO NOT EDIT THIS FILE WITHOUT ADHERING TO THE SYNTAX OF
GEN_GEN_C. This is described in the gen_gen.txt and gen_gen2.txt
files in the ~/reason/squares/gen_gen/text directory. Names of
functions not using CHB, CHK, or IFF have been removed to eliminate
compiler warnings and will have to be restored to conform to
gen_gen_C.

In the code, where a digit is a character, it is called "digit", and
where a digit is an index, it is called "digi".

This solves all puzzles that have been tried. It does not try to
fill in squares by guessing, but it does make a guess and look for
a contradiction.
 
This version of the sudoku solver is not suitable as input to the
single solver generator generator (gen_gen).

Sudoku differs from other squares puzzles in having a fixed size,
9 by 9 and using boxes, which are subsets of squares. Hence, it
is not describable in the current version of the language used
to describe other squares puzzles.

*/

/*************************************************************************/

/* includes

*/

#include <stdio.h>
#include <math.h>
#include <string.h>

/*************************************************************************/

/* hash_defs

*/

#define AND       &&
#define IS        ==
#define ISNT      !=
#define NOT       !
#define OR        ||
#define SET_TO    =
#define OK        0
#define ERROR     -1
#define TEXT_SIZE 128

/*************************************************************************/

/* hash_macros

*/

#define CHK(testbad, error_msg)           \
 if (testbad){                            \
   if (world->verbose)                    \
     printf("%s: %s\n", name, error_msg); \
   return ERROR; }                        \
 else

#define CHB(testbad, error_msg)         \
 if (testbad){                          \
   printf("%s: %s\n", name, error_msg); \
   return ERROR; }                      \
 else

#define IFF(tryit)         \
 if (tryit ISNT OK){       \
   if (world->verbose)     \
     printf("%s\n", name); \
   return ERROR; }         \
 else

#define boxFor(row,col)  ((3 * ((row) / 3)) + ((col) / 3))

/*************************************************************************/

/* structures

In the choices array, for a square of the puzzle in a given row and
column, there is an array of nine integers (used as booleans). The
first place in the array represents whether 1 is a choice for the
number at the given row and column. A 1 at that place means yes; a 0
means no. Similarly for the other eight entries in the array.
For example if 2, 7, and 9 are the choices for the square at row
4 and column 5, then choices[4][5] is {0, 1, 0, 0, 0, 0, 1, 0, 1}

The sizes array contains, for a square at a given row and column, the
number of 1's in the choices array for that square, except that 1
means there is 1 choice but it has not yet been recorded in the
squares array, and 10 means there is one choice and it has been
recorded. In the example above, sizes[4][5] is 3.

The squares array contains the puzzle.

The rows, cols, and boxes are each arrays indicating how many different
places within the row, column, or box a digit may go. For example,
if rows[2][5] is 7, that means in the third row (index 2) the digit
6 (index 5) may fit in 7 different squares. If a digit has been
placed in a row, column, or box, its indicator is set to 10.

For boxes, the 9 boxes within the puzzle are indexed as shown below.

    0 1 2
    3 4 5
    6 7 8

All of the structures are updated as solving proceeds.

*/

struct sudoku_world
{
  int boxes[9][9];              /* number of places digit fits in boxes    */
  int choices[9][9][9];         /* choices in squares                      */
  int cols[9][9];               /* number of places digit fits in columns  */
  int find_all;                 /* set to 1 if all answers to be found     */
  char logic[TEXT_SIZE][TEXT_SIZE]; /* explanation of changes in puzzle    */
  int logic_line;               /* number of next line of logic to write   */
  int print_all;                /* set to 1 for printing partial solutions */
  int print_choices;            /* set to 1 to print choices, 0=not        */
  int progress;                 /* set to 1 if progress made by solve loop */
  int rows[9][9];               /* number of places digit fits in rows     */
  int sizes[9][9];              /* array of sizes of choices               */
  char squares[9][9];           /* array of squares                        */
  int undone;                   /* number of squares remaining to be set   */
  int verbose;                  /* verbose (non-zero) or not (zero)        */
};

/*************************************************************************/

/* declare_functions

*/

int check_sizes(int sizes[9][9], int choices[9][9][9]);
int choices_same(int * choices1, int * choices2);
int choices_subset( int * choices1, int * choices2);
int delete_choice(int row, int col, int digi, int less, sudoku_world * world);
int digit_fits(char digit, int row, int col, int * no_fit,
  sudoku_world * world);
int explain_sudoku(struct sudoku_world * world);
int find_box_row_col(int box, int place, int * row, int * col);
int find_column_width(int col, int * width, struct sudoku_world * world);
int find_digit_in_box(int box, int digi, int occurrence, int * row,
  int * col, struct sudoku_world * world);
int find_digit_in_col(int col, int digi, int occurrence,
  int * row, struct sudoku_world * world);
int find_digit_in_row(int row, int digi, int occurrence,
  int * col, struct sudoku_world * world);
int find_three_box_3_3_3(int box, int place, int row1, int col1, int * row2,
  int * row3, int * col2, int * col3, int * digi1, int * digi2, int * digi3,
  struct sudoku_world * world);
int find_three_box_3_3_2(int box, int place, int row1, int col1, int * row2,
  int * row3, int * col2, int * col3, int * digi1, int * digi2, int * digi3,
  struct sudoku_world * world);
int find_three_box_3_2_2(int box, int row1, int col1, int * row2,
  int * row3, int * col2, int * col3, int * digi1, int * digi2, int * digi3,
  struct sudoku_world * world);
int find_three_box_2_2_2(int box, int place, int row1, int col1, int * row2,
  int * row3, int * col2, int * col3, int * digi1, int * digi2, int * digi3,
  struct sudoku_world * world);
int find_three_col_3_3_3(int col, int row1, int * row2, int * row3,
  int * digi1, int * digi2, int * digi3, struct sudoku_world * world);
int find_three_col_3_3_2(int col, int row1, int * row2, int * row3,
  int * digi1, int * digi2, int * digi3, struct sudoku_world * world);
int find_three_col_3_2_2(int col, int row1, int * row2, int * row3,
  int * digi1, int * digi2, int * digi3, struct sudoku_world * world);
int find_three_col_2_2_2(int col, int row1, int * row2, int * row3,
  int * digi1, int * digi2, int * digi3, struct sudoku_world * world);
int find_three_digits(int * choices, int * digi1, int * digi2, int * digi3);
int find_three_row_3_3_3(int row, int col1, int * col2, int * col3,
  int * digi1, int * digi2, int * digi3, struct sudoku_world * world);
int find_three_row_3_3_2(int row, int col1, int * col2, int * col3,
  int * digi1, int * digi2, int * digi3, struct sudoku_world * world);
int find_three_row_3_2_2(int row, int col1, int * col2, int * col3,
  int * digi1, int * digi2, int * digi3, struct sudoku_world * world);
int find_three_row_2_2_2(int row, int col1, int * col2, int * col3,
  int * digi1, int * digi2, int * digi3, struct sudoku_world * world);
int find_two_digits(int * choices, int * digi1, int * digi2);
int init_world(struct sudoku_world * world);
int main(int argc, char ** argv);
int print_sudoku(struct sudoku_world * world);
int print_sudoku_no_choices(struct sudoku_world * world);
int print_sudoku_with_choices(struct sudoku_world * world);
int read_arguments(int argc, char ** argv, struct sudoku_world * world);
int read_problem(char * file_name, struct sudoku_world * world);
int record_progress(char * message, struct sudoku_world * world);
int reduce_boxes(int row, int col, int digi, sudoku_world * world);
int reduce_box_three(int box, int row1, int row2, int row3, int col1, int col2,
  int col3, int digi1, int digi2, int digi3, struct sudoku_world * world);
int reduce_col_three(int col, int row1, int row2, int row3, int digi1,
  int digi2, int digi3, int * reduced, struct sudoku_world * world);
int reduce_cols(int row, int col, int digi, sudoku_world * world);
int reduce_one(int row, int col, int digi, int * reduced, int isRow,
  struct sudoku_world * world);
int reduce_row_three(int row, int col1, int col2, int col3, int digi1,
  int digi2, int digi3, int * reduced, struct sudoku_world * world);
int reduce_rows(int row, int col, int digi, sudoku_world * world);
int run_round(int choices[9][9][9], int sizes1[9][9], int row_factor,
  struct sudoku_world * world);
int solve_problem(struct sudoku_world * world);
int try_box_box_col(struct sudoku_world * world);
int try_box_box_row(struct sudoku_world * world);
int try_box_one(struct sudoku_world * world);
int try_box_same_rc(struct sudoku_world * world);
int try_box_three(struct sudoku_world * world);
int try_box_two(struct sudoku_world * world);
int try_chain(struct sudoku_world * world);
int try_chain_from(int row, int col, int rounds, struct sudoku_world * world);
int try_col_one(struct sudoku_world * world);
int try_col_same_box(struct sudoku_world * world);
int try_col_two(struct sudoku_world * world);
int try_col_three(struct sudoku_world * world);
int try_col_Xwing(struct sudoku_world * world);
int try_no_choice(struct sudoku_world * world);
int try_no_choice_from(int row, int col, int rounds,
  struct sudoku_world * world);
int try_row_one(struct sudoku_world * world);
int try_row_same_box(struct sudoku_world * world);
int try_row_two(struct sudoku_world * world);
int try_row_three(struct sudoku_world * world);
int try_row_Xwing(struct sudoku_world * world);
int try_square_one(struct sudoku_world * world);
int try_stack_digi( int stack, int digi, struct sudoku_world * world);
int try_tier_digi(int tier, int digi, struct sudoku_world * world);

/*************************************************************************/

/* globals

*/

/*************************************************************************/

/* define_functions

*/

/*************************************************************************/

/* check_sizes

Returned Value: int
  If there is any square in which sizes is not the number of 1's
  in the choices, this returns ERROR. Otherwise, it returns OK.

Called By: not currently called. Used for debugging

*/

int check_sizes(       /* ARGUMENTS        */
 int sizes[9][9],      /* sizes to check   */
 int choices[9][9][9]) /* choices to check */
{
  int row;
  int col;
  int digi;
  int size;

  for (row SET_TO 0; row < 9; row++)
    {
      for (col SET_TO 0; col < 9; col++)
	{
	  size SET_TO 0;
	  for(digi SET_TO 0; digi < 9; digi++)
	    {
	      if (choices[row][col][digi] IS 1)
		size++;
	    }
	  if ((sizes[row][col] IS 10) AND (size ISNT 1))
	    return ERROR;
	  else if ((sizes[row][col] < 10) AND
		   (sizes[row][col] ISNT size))
	    return ERROR;
	}
    }
  return OK;
}

/*************************************************************************/

/* choices_same

Returned Value: int
If choices1 (an array of 9 ints) is the same as choices2, this return 1.
Otherwise, it returns 0.

Called By:
  find_three_box_3_3_3
  find_three_box_3_3_2
  find_three_col_3_3_3
  find_three_col_3_3_2
  find_three_row_3_3_3
  find_three_row_3_3_2
  try_box_two
  try_col_two
  try_row_two

Side effects: none

*/

int choices_same( /* ARGUMENTS                     */
 int * choices1,  /* first set of choices to test  */
 int * choices2)  /* second set of choices to test */
{
  int n;

  for (n SET_TO 0; n < 9; n++)
    {
      if (choices1[n] ISNT choices2[n])
	break;
    }
  return ((n IS 9) ? 1 : 0);
}

/*************************************************************************/

/* choices_subset

Returned Value: int
If choices1 (an array of 9 ints) is a subset of choices2, this return 1.
Otherwise, it returns 0.

Called By:
  find_three_box_3_3_2
  find_three_col_3_3_2
  find_three_col_3_2_2
  find_three_row_3_3_2
  find_three_row_3_2_2

Side Effects: none

Being a subset means that wherever choices1 is 1, choices2 is also 1.

*/

int choices_subset( /* ARGUMENTS                      */
 int * choices1,    /* choices that might be subset   */
 int * choices2)    /* choices that might be superset */
{
  int n;

  for (n SET_TO 0; n < 9; n++)
    {
      if ((choices1[n] IS 1) AND (choices2[n] ISNT 1))
	break;
    }
  return ((n IS 9) ? 1 : 0);
}

/*************************************************************************/

/* delete_choice

Returned Value: int (OK)

Called By:
  reduce_boxes
  reduce_cols
  reduce_one
  reduce_rows
  try_box_one
  try_col_one
  try_row_one

Side Effects: This sets the choice value for the given index in the given
row and column to 0. It also reduces the rows, cols, and boxes value
for that index by 1.

*/

int delete_choice(     /* ARGUMENTS                    */
 int row,              /* row from which to delete     */
 int col,              /* column from which to delete  */
 int digi,             /* index at which to delete     */
 int less,             /* 1=reduce size, 0=don't       */
 sudoku_world * world) /* world model                  */
{
  world->choices[row][col][digi] SET_TO 0;
  world->cols[col][digi]--;
  world->rows[row][digi]--;
  world->boxes[boxFor(row, col)][digi]--;
  if (less)
    world->sizes[row][col]--;
  return OK;
}

/*************************************************************************/

/* digit_fits

Returned Value: int (OK)

Called By:
  init_solve_problem
  read_problem

Side Effects: If the digit fits at the given row and column, *fits is
set to 1. Otherwise, *fits is set to 0.

*/

int digit_fits(        /* ARGUMENTS                    */
 char digit,           /* digit to test                */
 int row,              /* row to test                  */
 int col,              /* column to test               */
 int * fits,           /* 1=fits, 0=does not, set here */
 sudoku_world * world) /* world model                  */
{
  int i;   /* row index                     */
  int j;   /* column index                  */
  int i1;  /* starting row index for box    */
  int i2;  /* stopping row index for box    */
  int j1;  /* starting column index for box */
  int j2;  /* stopping column index for box */

  if (world->squares[row][col] ISNT ' ')
    {
      *fits SET_TO 0;
    }
  else
    {
      *fits SET_TO 1;
      for (j SET_TO 0; ((j < 9) AND (*fits IS 1)); j++)
	{
	  if (digit IS world->squares[row][j])
	    *fits SET_TO 0;
	}
      for (i SET_TO 0; ((i < 9) AND (*fits IS 1)); i++)
	{
	  if (digit IS world->squares[i][col])
	    *fits SET_TO 0;
	}
      if (*fits IS 1)
	{
	  if (row < 3)
	    {
	      i1 SET_TO 0;
	      i2 SET_TO 3;
	    }
	  else if (row > 5)
	    {
	      i1 SET_TO 6;
	      i2 SET_TO 9;
	    }
	  else
	    {
	      i1 SET_TO 3;
	      i2 SET_TO 6;
	    }
	  if (col < 3)
	    {
	      j1 SET_TO 0;
	      j2 SET_TO 3;
	    }
	  else if (col > 5)
	    {
	      j1 SET_TO 6;
	      j2 SET_TO 9;
	    }
	  else
	    {
	      j1 SET_TO 3;
	      j2 SET_TO 6;
	    }
	  for (i SET_TO i1; ((i < i2) AND (*fits IS 1)); i++)
	    {
	      for (j SET_TO j1; ((j < j2) AND (*fits IS 1)); j++)
		{
		  if (world->squares[i][j] IS digit)
		    *fits SET_TO 0;
		}
	    }
	}
    }
  return OK;
}

/*************************************************************************/

/* explain_sudoku

Returned Value: int (OK)

Called By:  solve_problem

Side Effects: This prints the explanation of the steps in solving the
puzzle, which has been accumulated in the world->logic array of strings.

*/

int explain_sudoku(           /* ARGUMENTS    */
 struct sudoku_world * world) /* world model  */
{
  int line;      /* index of logic line */

  printf("\nEXPLANATION\n");
  printf("-----------\n");
  printf("  [A,B] means row A, column B.\n");
  printf("  Rows are numbered top to bottom, columns left to right.\n");
  printf("  Row and column numbers start at 1.\n\n");
  for (line SET_TO 0; line < world->logic_line; line++)
    printf("%s\n", world->logic[line]);
  return OK;
}

/*************************************************************************/

/* find_box_row_col

Returned Value: int
If any of the following errors occurs, this returns ERROR.
Otherwise, it returns OK.
1. The value of box is out of range: "box value out of range".
2. The value of place is out of range: "place value out of range".

Called By:
  find_digit_in_box
  find_three_box_3_3_3
  find_three_box_3_3_2
  find_three_box_3_2_2
  find_three_box_2_2_2
  reduce_box_three
  run_round
  try_box_one
  try_box_three
  try_box_two
  try_col_same_box
  try_row_same_box

Side Effects: This sets the values of row and col.

*/

int find_box_row_col( /* ARGUMENTS                                  */
 int box,             /* box for which to find row and col          */
 int place,           /* place in box for which to find row and col */
 int * row,           /* row for box and place, set here            */
 int * col)           /* column for box and place, set here         */
{
  const char * name SET_TO "find_box_row_col";

  CHB(((box < 0) OR (box > 8)), "box value out of range");
  CHB(((place < 0) OR (place > 8)), "place value out of range");
  *row SET_TO (((box / 3) * 3) + (place / 3));
  *col SET_TO (((box % 3) * 3) + (place % 3));
  return OK;
}

/*************************************************************************/

/* find_column_width

Returned Value: int (OK)

Called By: print_sudoku_with_choices

Side Effects: The value of the printing width of a column is set.

The width is set to two more than the maximum number of choices in
the column, if any row has one or more choices. Otherwise, it is set to 1.

*/

int find_column_width(        /* ARGUMENTS                          */
 int col,                     /* the column for which to find width */
 int * width,                 /* the width, set here                */
 struct sudoku_world * world) /* world model                        */
{
  int row;
  int size;
  int has_choices;

  size SET_TO 1;
  has_choices SET_TO 0;
  for (row SET_TO 0; row < 9; row++)
    {
      if (world->squares[row][col] IS ' ')
	{
	  has_choices SET_TO 1;
	  if (world->sizes[row][col] > size)
	    size SET_TO world->sizes[row][col];
	}
    }
  *width SET_TO (has_choices ? (size + 2) : 1);
  return OK;
}

/*************************************************************************/

/* find_digit_in_box

Returned Value: int
If any of the following errors occurs, this returns ERROR.
Otherwise, it returns OK.
1. find_box_row_col returns ERROR
2. The nth occurrence of the digit is not found: "occurrence not found".

Called By: try_box_same_rc

Side Effects: row and col are set

In the given box, this finds the row and column indexes of the nth
occurrence of the digit whose index is given and sets *row and *col to
those indexes. The indexes are one less than the printed value, as usual.

*/

int find_digit_in_box(        /* ARGUMENTS                            */
 int box,                     /* box in which to find digit           */
 int digi,                    /* index of digit                       */
 int occurrence,              /* index of occurrence (0 = 1st)        */
 int * row,                   /* row of digit occurrence, set here    */
 int * col,                   /* column of digit occurrence, set here */
 struct sudoku_world * world) /* world model                          */
{
  const char * name SET_TO "find_digit_in_box";
  int place;

  for (place SET_TO 0; place < 9; place++)
    {
      IFF(find_box_row_col(box, place, row, col));
      if (world->choices[*row][*col][digi])
	{
	  if (occurrence IS 1)
	    {
	      break;
	    }
	  else
	    occurrence--;
	}
    }
  CHB ((place IS 9), "occurrence not found");
  return OK;
}

/*************************************************************************/

/* find_digit_in_col

Returned Value: int
If any of the following errors occurs, this returns ERROR.
Otherwise, it returns OK.
1. The nth occurrence of the digit is not found: "occurrence not found".

Called By:
  try_col_same_box
  try_col_Xwing

Side Effects: row is set

In the given column, this finds the row index of the nth occurrence of
the digit whose index is given and sets *row to that index. The indexes
are one less than the value, as usual.

*/

int find_digit_in_col(        /* ARGUMENTS                         */
 int col,                     /* column in which to find digit     */
 int digi,                    /* digit to find in column           */
 int occurrence,              /* index of occurrence (0 = 1st)     */
 int * row,                   /* row of digit occurrence, set here */
 struct sudoku_world * world) /* world model                       */
{
  const char * name SET_TO "find_digit_in_col";
  int j;

  for (j SET_TO 0; j < 9; j++)
    {
      if (world->choices[j][col][digi])
	{
	  if (occurrence IS 1)
	    {
	      *row SET_TO j;
	      break;
	    }
	  else
	    occurrence--;
	}
    }
  CHB ((j IS 9), "occurrence not found");
  return OK;
}

/*************************************************************************/

/* find_digit_in_row

Returned Value: int
If any of the following errors occurs, this returns ERROR.
Otherwise, it returns OK.
1. The nth occurrence of the digit is not found: "occurrence not found".
 
Called By:
  try_row_same_box
  try_row_Xwing

In the given row, this finds the column index of the nth occurrence of
the digit whose index is given and sets *col to that index. The indexes
are one less than the value, as usual.

*/

int find_digit_in_row(        /* ARGUMENTS                            */
 int row,                     /* row in which to find digit           */
 int digi,                    /* digit to find in row                 */
 int occurrence,              /* index of occurrence (0 = 1st)        */
 int * col,                   /* column of digit occurrence, set here */
 struct sudoku_world * world) /* world model                          */
{
  const char * name SET_TO "find_digit_in_row";
  int j;

  for (j SET_TO 0; j < 9; j++)
    {
      if (world->choices[row][j][digi])
	{
	  if (occurrence IS 1)
	    {
	      *col SET_TO j;
	      break;
	    }
	  else
	    occurrence--;
	}
    }
  CHB ((j IS 9), "occurrence not found");
  return OK;
}

/*************************************************************************/

/* find_three_box_3_3_3

Returned Value: int
If any of the following errors occurs, this returns ERROR.
Otherwise, it returns OK.
1. find_box_row_col returns ERROR
2. find_three_digits returns ERROR

Called By: try_box_three

When this is called, it is known that in the given box there are three
choices in the square at [row1,col1], whose box index is place. This
looks for two more squares [row2,col2] and [row3,col3] in the same
box, each of which has the same three choices as [row1,col1]. If such
squares are found, the choices for [row1,col1] are found and recorded
in digi1, digi2, and digi3.

Before this is called, digi3 can be set to -1 to serve as a flag.
If digi3 is still -1 after this function is called, the function did
not find squares with the required properties.

*/

int find_three_box_3_3_3(     /* ARGUMENTS                                   */
 int box,                     /* box to look in                              */
 int place,                   /* place in box that has three choices         */
 int row1,                    /* row of place                                */
 int col1,                    /* column of place                             */
 int * row2,                  /* row of 2nd square with same choices, set    */
 int * row3,                  /* row of 3rd square with same choices, set    */
 int * col2,                  /* column of 2nd square with same choices, set */
 int * col3,                  /* column of 3rd square with same choices, set */
 int * digi1,                 /* first of three choices, set here            */
 int * digi2,                 /* second of three choices, set here           */
 int * digi3,                 /* third of three choices, set here            */
 struct sudoku_world * world) /* world model                                 */
{
  const char * name SET_TO "find_three_box_3_3_3";

  for (place++; place < 8; place++)
    {
      IFF(find_box_row_col(box, place, row2, col2));
      if (choices_same(world->choices[row1][col1],
		       world->choices[*row2][*col2]))
	break;
    }
  if (place < 8)
    {
       for (place++; place < 9; place++)
	 {
	   IFF(find_box_row_col(box, place, row3, col3));
	   if (choices_same(world->choices[row1][col1],
			    world->choices[*row3][*col3]))
	     break;
	 }
    }
  else
    place SET_TO 9;
  if (place < 9)
    {
      IFF(find_three_digits(world->choices[row1][col1],
			     digi1, digi2, digi3));
    }
  return OK;
}

/*************************************************************************/

/* find_three_box_3_3_2

Returned Value: int
If any of the following errors occurs, this returns ERROR.
Otherwise, it returns OK.
1. find_box_row_col returns ERROR
2. find_three_digits returns ERROR

Called By: try_box_three

Side Effects: When this is called, it is known that in the given box
there are three choices in the square at [row1,col1]. This looks for a
second square, [row2,col2], in the box that has the same three
choices. If such a square is found, this looks for a third square
[row3,col3] that has two choices that are also choices in [row1,col1].
If [row2,col2] and [row3,col3] are found, the choices for col1 are
found and recorded in digi1, digi2, and digi3.

Before this is called, digi3 can be set to -1 to serve as a flag.
If digi3 is still -1 after this function is called, the function did
not find squares with the required properties.

*/

int find_three_box_3_3_2(     /* ARGUMENTS                                   */
 int box,                     /* box to look in                              */
 int place,                   /* place in box that has three choices         */
 int row1,                    /* row of place                                */
 int col1,                    /* column of place                             */
 int * row2,                  /* row of 2nd square with same choices, set    */
 int * row3,                  /* row of 3rd square with 2 choices same, set  */
 int * col2,                  /* column of 2nd square with same choices, set */
 int * col3,                  /* col of 3rd square with 2 choices same, set  */
 int * digi1,                 /* first of three choices, set here            */
 int * digi2,                 /* second of three choices, set here           */
 int * digi3,                 /* third of three choices, set here            */
 struct sudoku_world * world) /* world model                                 */
{
  const char * name SET_TO "find_three_box_3_3_2";

  for (place++; place < 9; place++)
    {
      IFF(find_box_row_col(box, place, row2, col2));
      if (choices_same(world->choices[row1][col1],
		       world->choices[*row2][*col2]))
	break;
    }
  if (place < 9)
    {
      for (place SET_TO 0; place < 9; place++)
	{
	  IFF(find_box_row_col(box, place, row3, col3));
	  if ((world->sizes[*row3][*col3] IS 2) AND
	      (choices_subset(world->choices[*row3][*col3],
			      world->choices[row1][col1])))
	    break;
	}
    }
  if (place < 9)
    {
      IFF(find_three_digits(world->choices[row1][col1], digi1, digi2, digi3));
    }
  return OK;
}

/*************************************************************************/

/* find_three_box_3_2_2

Returned Value: int
If any of the following errors occurs, this returns ERROR.
Otherwise, it returns OK.
1. find_box_row_col returns ERROR
2. find_three_digits returns ERROR

Called By: try_box_three

Side Effects: When this is called, it is known that in the given box
there are three choices in [row1,col1]. This looks for two more
squares in the same box, [row2,col2] and [row3,col3] each of which has
two choices and the choices are subsets of the choices in [row1,col1].
If [row2,col2] and [row3,col3] are found, the choices for [row1,col1]
are found and recorded in digi1, digi2, and digi3.

Before this is called, digi3 can be set to -1 to serve as a flag.
If digi3 is still -1 after this function is called, the function did
not find squares with the required properties.

It is not necessary to test that the two choices in [row2,col2] and
[row3,col3] are not identical, because if they were identical, that
would have been picked up by try_box_two (which is called before
try_box_three) and those two choices would have been deleted from
[row1,col1].

*/

int find_three_box_3_2_2(     /* ARGUMENTS                                  */
 int box,                     /* box to look in                             */
 int row1,                    /* row in box that has three choices          */
 int col1,                    /* column in box that has three choices       */
 int * row2,                  /* row of 2nd square with 2 choices same, set */
 int * row3,                  /* row of 3rd square with 2 choices same, set */
 int * col2,                  /* col of 2nd square with 2 choices same, set */
 int * col3,                  /* col of 3rd square with 2 choices same, set */
 int * digi1,                 /* first of three choices, set here           */
 int * digi2,                 /* second of three choices, set here          */
 int * digi3,                 /* third of three choices, set here           */
 struct sudoku_world * world) /* world model                                */
{
  const char * name SET_TO "find_three_box_3_2_2";
  int place;

  for (place SET_TO 0; place < 9; place++)
    {
      IFF(find_box_row_col(box, place, row2, col2));
      if ((world->sizes[*row2][*col2] IS 2) AND
	  (choices_subset(world->choices[*row2][*col2],
			  world->choices[row1][col1])))
	break;
    }
  if (place < 9)
    {
      for (place++; place < 9; place++)
	{
	  IFF(find_box_row_col(box, place, row3, col3));
	  if ((world->sizes[*row3][*col3] IS 2) AND
	      (choices_subset(world->choices[*row3][*col3],
			      world->choices[row1][col1])))
	    break;
	}
    }
  if (place < 9)
    {
      IFF(find_three_digits(world->choices[row1][col1],
			     digi1, digi2, digi3));
    }
  return OK;
}

/*************************************************************************/

/* find_three_box_2_2_2

Returned Value: int
If any of the following errors occurs, this returns ERROR.
Otherwise, it returns OK.
1. find_box_row_col returns ERROR
2. find_two_digits returns ERROR

Called By: try_box_three

Side Effects: When this is called, it is known that in the given box
there are two choices in [row1,col1], which is at the given value of
place. This looks for a second square in the same box, [row2,col2],
that shares exactly one choice with the first square, so that there
are three choices all told in the two squares. If the second square is
found, this looks for a third square, [row3,col3], whose choices are a
subset of the three choices already found.  If [row3,col3] is found,
the three choices are recorded in digi1, digi2, and digi3. If not,
digi3 is set to -1.

Before this is called, digi3 can be set to -1 to serve as a flag.
If digi3 is still -1 after this function is called, the function did
not find squares with the required properties.

It is not necessary to test that the two choices in [row2,col2] and
[row3,col3] are not identical, because if they were identical, that
would have been picked up by try_box_two (which is called before
try_box_three) and those two choices would have been deleted from
[row1,col1]. Similarly, it is not necessary to check that the two
choices in [row1,col1] and [row3,col3] are not identical.

*/

int find_three_box_2_2_2(     /* ARGUMENTS                                  */
 int box,                     /* box to look in                             */
 int place,                   /* place in box that has two choices          */
 int row1,                    /* row of place                               */
 int col1,                    /* column of place                            */
 int * row2,                  /* row of 2nd square with shared choice, set  */
 int * row3,                  /* row of 3rd square with 2 choices same, set */
 int * col2,                  /* col of 2nd square with shared choice, set  */
 int * col3,                  /* col of 3rd square with 2 choices same, set */
 int * digi1,                 /* first of three choices, set here           */
 int * digi2,                 /* second of three choices, set here          */
 int * digi3,                 /* third of three choices, set here           */
 struct sudoku_world * world) /* world model                                */
{
  const char * name SET_TO "find_three_box_2_2_2";
  int place2;
  int digi4;
  int digi5;

  IFF(find_two_digits(world->choices[row1][col1], digi1, digi2));
  for (place++; place < 8; place++)
    {
      IFF(find_box_row_col(box, place, row2, col2));
      if (world->sizes[*row2][*col2] ISNT 2)
	continue;
      IFF(find_two_digits(world->choices[*row2][*col2], &digi4, &digi5));
      if ((*digi1 IS digi4) AND (*digi2 IS digi5))
	{
	  continue;
	}
      *digi3 SET_TO ((*digi1 IS digi4) ? digi5 :
		      (*digi1 IS digi5) ? digi4 :
		      (*digi2 IS digi4) ? digi5 :
		      (*digi2 IS digi5) ? digi4 : -1);
      if (*digi3 IS -1)
	continue;
      for (place2 SET_TO (place + 1); place2 < 9; place2++)
	{
	  IFF(find_box_row_col(box, place2, row3, col3));
	  if (world->sizes[*row3][*col3] ISNT 2)
	    continue;
	  IFF(find_two_digits(world->choices[*row3][*col3], &digi4, &digi5));
	  if (((digi4 IS *digi1) AND
	       ((digi5 IS *digi2) OR (digi5 IS *digi3))) OR
	      ((digi4 IS *digi2) AND
	       ((digi5 IS *digi1) OR (digi5 IS *digi3))) OR
	      ((digi4 IS *digi3) AND
	       ((digi5 IS *digi1) OR (digi5 IS *digi2))))
	    break;
	}
      if (place2 ISNT 9)
	break;
      else
	*digi3 SET_TO -1;
    }
  return OK;
}

/*************************************************************************/

/* find_three_col_3_3_3

Returned Value: int
If any of the following errors occurs, this returns ERROR.
Otherwise, it returns OK.
  1. find_three_digits returns ERROR

Called By: try_col_three

When this is called, it is known that there are three choices in the
square at [row1, col]. This looks for two more rows (row2 and row3),
such that the squares at [row2,col] and [row3,col] have the same three
choices as the square at [row1,col].  If row2 and row3 are found, the
choices for the square at [row1,col] are found and recorded in digi1,
digi2, and digi3.

Before this is called, digi3 can be set to -1 to serve as a flag.
If digi3 is still -1 after this function is called, the function did
not find squares with the required properties.

*/

int find_three_col_3_3_3(     /* ARGUMENTS                                */
 int col,                     /* column to look in                        */
 int row1,                    /* row of 1st square with same choices      */
 int * row2,                  /* row of 2nd square with same choices, set */
 int * row3,                  /* row of 3rd square with same choices, set */
 int * digi1,                 /* first of three choices, set here         */
 int * digi2,                 /* second of three choices, set here        */
 int * digi3,                 /* third of three choices, set here         */
 struct sudoku_world * world) /* world model                              */
{
  const char * name SET_TO "find_three_col_3_3_3";

  for (*row2 SET_TO (row1 + 1); *row2 < 8; *row2 SET_TO (*row2 + 1))
    {
      if (choices_same(world->choices[row1][col],
		       world->choices[*row2][col]))
	break;
    }
  if (*row2 < 8)
    {
       for (*row3 SET_TO (*row2 + 1); *row3 < 9; *row3 SET_TO (*row3 + 1))
	 {
	   if (choices_same(world->choices[row1][col],
			    world->choices[*row3][col]))
	     break;
	 }
    }
  if ((*row2 < 8) AND (*row3 < 9))
    {
      IFF(find_three_digits(world->choices[row1][col],
			     digi1, digi2, digi3));
    }
  return OK;
}

/*************************************************************************/

/* find_three_col_3_3_2

Returned Value: int
If any of the following errors occurs, this returns ERROR.
Otherwise, it returns OK.
  1. find_three_digits returns ERROR

Called By: try_col_three

Side Effects: When this is called, it is known that there are three
choices in the square at [row1,col]. This looks for a second square,
[row2,col], that has the same three choices. If such a square is
found, this looks for a third square [row3,col] that has two choices
that are also choices in [row1,col]. If row2 and row3 are found, the
choices for the square at [row1,col] are found and recorded in digi1,
digi2, and digi3.

Before this is called, digi3 can be set to -1 to serve as a flag.
If digi3 is still -1 after this function is called, the function did
not find squares with the required properties.

*/

int find_three_col_3_3_2(     /* ARGUMENTS                                   */
 int col,                     /* column to look in                           */
 int row1,                    /* row of 1st square with three choices        */
 int * row2,                  /* row of 2nd square with same choices, set    */
 int * row3,                  /* row of 3rd square with 2 choices same, set  */
 int * digi1,                 /* first of three choices, set here            */
 int * digi2,                 /* second of three choices, set here           */
 int * digi3,                 /* third of three choices, set here            */
 struct sudoku_world * world) /* world model                                 */
{
  const char * name SET_TO "find_three_col_3_3_2";

  for (*row2 SET_TO (row1 + 1); *row2 < 9; *row2 SET_TO (*row2 + 1))
    {
      if (choices_same(world->choices[row1][col],
		       world->choices[*row2][col]))
	break;
    }
  if (*row2 < 9)
    {
       for (*row3 SET_TO 0; *row3 < 9; *row3 SET_TO (*row3 + 1))
	 {
	   if ((world->sizes[*row3][col] IS 2) AND
	       (choices_subset(world->choices[*row3][col],
			       world->choices[row1][col])))
	     break;
	 }
    }
  if ((*row2 < 8) AND (*row3 < 9))
    {
      IFF(find_three_digits(world->choices[row1][col], digi1, digi2, digi3));
    }
  return OK;
}

/*************************************************************************/

/* find_three_col_3_2_2

Returned Value: int
If any of the following errors occurs, this returns ERROR.
Otherwise, it returns OK.
  1. find_three_digits returns ERROR

Called By: try_col_three

Side Effects: When this is called, it is known that in the given
column there are three choices in the square at [row1,col]. This looks
for two more rows (row2 and row3) such that the squares at [row2,col]
and [row3,col] each have two choices and the choices are subsets of
the choices in the square at [row1,col]. If col2 and col3 are found,
the choices for col1 are found and recorded in digi1, digi2, and
digi3.

It is not necessary to test that the two choices in [row2,col] and
[row3,col] are not identical, because if they were identical, that
would have been picked up by try_col_two (which is called before
try_col_three) and those two choices would have been deleted from
[row1,col].

Before this is called, digi3 can be set to -1 to serve as a flag.
If digi3 is still -1 after this function is called, the function did
not find squares with the required properties.

*/

int find_three_col_3_2_2(     /* ARGUMENTS                                  */
 int col,                     /* column to look in                          */
 int row1,                    /* row of 1st square with three choices       */
 int * row2,                  /* row of 2nd square with 2 choices same, set */
 int * row3,                  /* row of 3rd square with 2 choices same, set */
 int * digi1,                 /* first of three choices, set here           */
 int * digi2,                 /* second of three choices, set here          */
 int * digi3,                 /* third of three choices, set here           */
 struct sudoku_world * world) /* world model                                */
{
  const char * name SET_TO "find_three_col_3_2_2";

  for (*row2 SET_TO 0; *row2 < 8; *row2 SET_TO (*row2 + 1))
    {
      if ((world->sizes[*row2][col] IS 2) AND
	  (choices_subset(world->choices[*row2][col],
			  world->choices[row1][col])))
	break;
    }
  if (*row2 < 8)
    {
      for (*row3 SET_TO (*row2 + 1); *row3 < 9; *row3 SET_TO (*row3 + 1))
	{
	  if ((world->sizes[*row3][col] IS 2) AND
	      (choices_subset(world->choices[*row3][col],
			      world->choices[row1][col])))
	    break;
	}
    }
  if ((*row2 < 8) AND (*row3 < 9))
    {
      IFF(find_three_digits(world->choices[row1][col],
			     digi1, digi2, digi3));
    }
  return OK;
}

/*************************************************************************/

/* find_three_col_2_2_2

Returned Value: int
If any of the following errors occurs, this returns ERROR.
Otherwise, it returns OK.
  1. find_two_digits returns ERROR

Called By: try_col_three

Side Effects: When this is called, it is known that in the given
column there are two choices in the square at [row1,col]. This looks
for a second square in the same column, [row2,col], that shares
exactly one choice with the first square, so that there are three
choices all told in the two squares. If the second square is found,
this looks for a third square, [row3,col], whose choices are a subset
of the three choices already found.  If [row3,col] is found, the three
choices are recorded in digi1, digi2, and digi3. If not, digi3 is set
to -1.

In the check for duplicate pairs, this uses the property that
find_two_digits finds digits in order.

Before this is called, digi3 can be set to -1 to serve as a flag.
If digi3 is still -1 after this function is called, the function did
not find squares with the required properties.

It is not necessary to test that the two choices in [row2,col] and
[row3,col] are not identical, because if they were identical, that
would have been picked up by try_col_two (which is called before
try_col_three) and those two choices would have been deleted from
[row1,col]. Similarly, it is not necessary to check that the two
choices in [row1,col] and [row3,col] are not identical.

*/

int find_three_col_2_2_2(     /* ARGUMENTS                                  */
 int col,                     /* column to look in                          */
 int row1,                    /* row of square in column that has 2 choices */
 int * row2,                  /* row of 2nd square with shared choice, set  */
 int * row3,                  /* row of 3rd square with 2 choices same, set */
 int * digi1,                 /* first of three choices, set here           */
 int * digi2,                 /* second of three choices, set here          */
 int * digi3,                 /* third of three choices, set here           */
 struct sudoku_world * world) /* world model                                */
{
  const char * name SET_TO "find_three_col_2_2_2";
  int digi4;
  int digi5;

  IFF(find_two_digits(world->choices[row1][col], digi1, digi2));
  for (*row2 SET_TO (row1 + 1); *row2 < 8; *row2 SET_TO (*row2 + 1))
    {
      if (world->sizes[*row2][col] ISNT 2)
	continue;
      IFF(find_two_digits(world->choices[*row2][col], &digi4, &digi5));
      if ((*digi1 IS digi4) AND (*digi2 IS digi5))
	{
	  continue;
	}
      *digi3 SET_TO ((*digi1 IS digi4) ? digi5 :
		      (*digi1 IS digi5) ? digi4 :
		      (*digi2 IS digi4) ? digi5 :
		      (*digi2 IS digi5) ? digi4 : -1);
      if (*digi3 IS -1)
	continue;
      for (*row3 SET_TO (*row2 + 1); *row3 < 9; *row3 SET_TO (*row3 + 1))
	{
	  if (world->sizes[*row3][col] ISNT 2)
	    continue;
	  IFF(find_two_digits(world->choices[*row3][col], &digi4, &digi5));
	  if (((digi4 IS *digi1) AND
	       ((digi5 IS *digi2) OR (digi5 IS *digi3))) OR
	      ((digi4 IS *digi2) AND
	       ((digi5 IS *digi1) OR (digi5 IS *digi3))) OR
	      ((digi4 IS *digi3) AND
	       ((digi5 IS *digi1) OR (digi5 IS *digi2))))
	    break;
	}
      if (*row3 ISNT 9)
	break;
      else
	*digi3 SET_TO -1;
    }
  return OK;
}

/*************************************************************************/

/* find_three_digits

Returned Value: int
If any of the following errors occurs, this returns ERROR.
Otherwise, it returns OK.
  1. Exactly three digits are not found: "three digits were not set".

Called By:
  find_three_box_3_3_3
  find_three_box_3_3_2
  find_three_box_3_2_2
  find_three_col_3_3_3
  find_three_col_3_3_2
  find_three_col_3_2_2
  find_three_row_3_3_3
  find_three_row_3_3_2
  find_three_row_3_2_2

Side Effects: If there are exactly three non-zero choices, digi1,
digi2, and digi3 are set to the indexes of those choices. This is
normally called only if it is known that there are exactly three
choices.

*/

int find_three_digits( /* ARGUMENTS                         */
 int * choices,        /* array of nine possible choices    */
 int * digi1,          /* first of three choices, set here  */
 int * digi2,          /* second of three choices, set here */
 int * digi3)          /* third of three choices, set here  */
{
  const char * name SET_TO "find_three_digits";
  int j;
  int set;

  set SET_TO 0;
  for (j SET_TO 0; j < 9; j++)
    {
      if (choices[j])
	{
	  if (set IS 0)
	    {
	      *digi1 SET_TO j;
	    }
	  else if (set IS 1)
	    {
	      *digi2 SET_TO j;
	    }
	  else if (set IS 2)
	    {
	      *digi3 SET_TO j;
	    }
	  set++;
	}
    }
  CHB((set ISNT 3), "three digits were not set");
  return OK;
}

/*************************************************************************/

/* find_three_row_3_3_3

Returned Value: int
If any of the following errors occurs, this returns ERROR.
Otherwise, it returns OK.
  1. find_three_digits returns ERROR

Called By: try_row_three

When this is called, it is known that there are three choices in the
square at [row, col1]. This looks for two more columns (col2 and col3),
such that the squares at [row,col2] and [row,col2] have the same three
choices as the square at [row,col1].  If col2 and col3 are found, the
choices for the square at [row,col1] are found and recorded in digi1,
digi2, and digi3.

Before this is called, digi3 can be set to -1 to serve as a flag.
If digi3 is still -1 after this function is called, the function did
not find squares with the required properties.

*/

int find_three_row_3_3_3(     /* ARGUMENTS                                   */
 int row,                     /* row to look in                              */
 int col1,                    /* column of 1st square with same choices,     */
 int * col2,                  /* column of 2nd square with same choices, set */
 int * col3,                  /* column of 3rd square with same choices, set */
 int * digi1,                 /* first of three choices, set here            */
 int * digi2,                 /* second of three choices, set here           */
 int * digi3,                 /* third of three choices, set here            */
 struct sudoku_world * world) /* world model                                 */
{
  const char * name SET_TO "find_three_row_3_3_3";

  for (*col2 SET_TO (col1 + 1); *col2 < 8; *col2 SET_TO (*col2 + 1))
    {
      if (choices_same(world->choices[row][col1],
		       world->choices[row][*col2]))
	break;
    }
  if (*col2 < 8)
    {
       for (*col3 SET_TO (*col2 + 1); *col3 < 9; *col3 SET_TO (*col3 + 1))
	 {
	   if (choices_same(world->choices[row][col1],
			    world->choices[row][*col3]))
	     break;
	 }
    }
  if ((*col2 < 8) AND (*col3 < 9))
    {
      IFF(find_three_digits(world->choices[row][col1],
			     digi1, digi2, digi3));
    }
  return OK;
}

/*************************************************************************/

/* find_three_row_3_3_2

Returned Value: int
If any of the following errors occurs, this returns ERROR.
Otherwise, it returns OK.
  1. find_three_digits returns ERROR

Called By: try_row_three

Side Effects: When this is called, it is known that in the given row
there are three choices in col1. This looks for two more columns (col2
and col3). col2 must have the same three choices as col1. col3 must
have two choices that are also choices in col1. If col2 and col3 are
found, the choices for col1 are found and recorded in digi1, digi2,
and digi3.

*/

int find_three_row_3_3_2(     /* ARGUMENTS                                   */
 int row,                     /* row to look in                              */
 int col1,                    /* column of 1st square with three choices     */
 int * col2,                  /* column of 2nd square with same choices, set */
 int * col3,                  /* col of 3rd square with 2 choices same, set  */
 int * digi1,                 /* first of three choices, set here            */
 int * digi2,                 /* second of three choices, set here           */
 int * digi3,                 /* third of three choices, set here            */
 struct sudoku_world * world) /* world model                                 */
{
  const char * name SET_TO "find_three_row_3_3_2";

  for (*col2 SET_TO (col1 + 1); *col2 < 9; *col2 SET_TO (*col2 + 1))
    {
      if (choices_same(world->choices[row][col1],
		       world->choices[row][*col2]))
	break;
    }
  if (*col2 < 9)
    {
       for (*col3 SET_TO 0; *col3 < 9; *col3 SET_TO (*col3 + 1))
	 {
	   if ((world->sizes[row][*col3] IS 2) AND
	       (choices_subset(world->choices[row][*col3],
			       world->choices[row][col1])))
	     break;
	 }
    }
  if ((*col2 < 8) AND (*col3 < 9))
    {
      IFF(find_three_digits(world->choices[row][col1], digi1, digi2, digi3));
    }
  return OK;
}

/*************************************************************************/

/* find_three_row_3_2_2

Returned Value: int
If any of the following errors occurs, this returns ERROR.
Otherwise, it returns OK.
  1. find_three_digits returns ERROR

Called By: try_row_three

Side Effects: When this is called, it is known that in the given row
there are three choices in the square at [row,co1l]. This looks for two
more columns (col2 and col3) such that the squares at [row,col2] and
[row,col3] each have two choices and the choices are subsets of the
choices in the square at [row,col1]. If col2 and col3 are found, the
choices for col1 are found and recorded in digi1, digi2, and digi3.

It is not necessary to test that the two choices in [row,col2] and
[row,col3] are not identical, because if they were identical, that
would have been picked up by try_row_two (which is called before
try_row_three) and those two choices would have been deleted from
[row,col1].

Before this is called, digi3 can be set to -1 to serve as a flag.
If digi3 is still -1 after this function is called, the function did
not find squares with the required properties.

*/

int find_three_row_3_2_2(     /* ARGUMENTS                                  */
 int row,                     /* row to look in                             */
 int col1,                    /* column of 1st square with three choices    */
 int * col2,                  /* col of 2nd square with 2 choices same, set */
 int * col3,                  /* col of 3rd square with 2 choices same, set */
 int * digi1,                 /* first of three choices, set here           */
 int * digi2,                 /* second of three choices, set here          */
 int * digi3,                 /* third of three choices, set here           */
 struct sudoku_world * world) /* world model                                */
{
  const char * name SET_TO "find_three_row_3_2_2";

  for (*col2 SET_TO 0; *col2 < 8; *col2 SET_TO (*col2 + 1))
    {
      if ((world->sizes[row][*col2] IS 2) AND
	  (choices_subset(world->choices[row][*col2],
			  world->choices[row][col1])))
	break;
    }
  if (*col2 < 8)
    {
      for (*col3 SET_TO (*col2 + 1); *col3 < 9; *col3 SET_TO (*col3 + 1))
	{
	  if ((world->sizes[row][*col3] IS 2) AND
	      (choices_subset(world->choices[row][*col3],
			      world->choices[row][col1])))
	    break;
	}
    }
  if ((*col2 < 8) AND (*col3 < 9))
    {
      IFF(find_three_digits(world->choices[row][col1],
			     digi1, digi2, digi3));
    }
  return OK;
}

/*************************************************************************/

/* find_three_row_2_2_2

Returned Value: int
If any of the following errors occurs, this returns ERROR.
Otherwise, it returns OK.
  1. find_two_digits returns ERROR

Called By: try_row_three

Side Effects: When this is called, it is known that in the given
row there are two choices in the square at [row,col1]. This looks
for a second square in the same row, [row,col2], that shares
exactly one choice with the first square, so that there are three
choices all told in the two squares. If the second square is found,
this looks for a third square, [row,col3], whose choices are a subset
of the three choices already found.  If [row,col3] is found, the three
choices are recorded in digi1, digi2, and digi3. If not, digi3 is set
to -1.

In the check for duplicate pairs, this uses the property that
find_two_digits finds digits in order.

It is not necessary to test that the two choices in [row,col2] and
[row,col3] are not identical, because if they were identical, that
would have been picked up by try_row_two (which is called before
try_row_three) and those two choices would have been deleted from
[row,col1]. Similarly, it is not necessary to check that the two
choices in [row,col1] and [row,col3] are not identical.

*/

int find_three_row_2_2_2(     /* ARGUMENTS                                  */
 int row,                     /* row to look in                             */
 int col1,                    /* column of square in row that has 2 choices */
 int * col2,                  /* col of 2nd square with shared choice, set  */
 int * col3,                  /* col of 3rd square with 2 choices same, set */
 int * digi1,                 /* first of three choices, set here           */
 int * digi2,                 /* second of three choices, set here          */
 int * digi3,                 /* third of three choices, set here           */
 struct sudoku_world * world) /* world model                                */
{
  const char * name SET_TO "find_three_row_2_2_2";
  int digi4;
  int digi5;

  IFF(find_two_digits(world->choices[row][col1], digi1, digi2));
  for (*col2 SET_TO (col1 + 1); *col2 < 8; *col2 SET_TO (*col2 + 1))
    {
      if (world->sizes[row][*col2] ISNT 2)
	continue;
      IFF(find_two_digits(world->choices[row][*col2], &digi4, &digi5));
      if ((*digi1 IS digi4) AND (*digi2 IS digi5))
	{
	  continue;
	}
      *digi3 SET_TO ((*digi1 IS digi4) ? digi5 :
		      (*digi1 IS digi5) ? digi4 :
		      (*digi2 IS digi4) ? digi5 :
		      (*digi2 IS digi5) ? digi4 : -1);
      if (*digi3 IS -1)
	continue;
      for (*col3 SET_TO (*col2 + 1); *col3 < 9; *col3 SET_TO (*col3 + 1))
	{
	  if (world->sizes[row][*col3] ISNT 2)
	    continue;
	  IFF(find_two_digits(world->choices[row][*col3], &digi4, &digi5));
	  if (((digi4 IS *digi1) AND
	       ((digi5 IS *digi2) OR (digi5 IS *digi3))) OR
	      ((digi4 IS *digi2) AND
	       ((digi5 IS *digi1) OR (digi5 IS *digi3))) OR
	      ((digi4 IS *digi3) AND
	       ((digi5 IS *digi1) OR (digi5 IS *digi2))))
	    break;
	}
      if (*col3 ISNT 9)
	break;
      else
	*digi3 SET_TO -1;
    }
  return OK;
}

/*************************************************************************/

/* find_two_digits

Returned Value: int
If any of the following errors occurs, this returns ERROR.
Otherwise, it returns OK.
  1. exactly two digits are not found: "two digits were not set"

Called By:
  find_three_box_2_2_2
  find_three_col_2_2_2
  find_three_row_2_2_2
  try_box_two
  try_col_two
  try_row_two

Side Effects: The values of digi1 and digi2 are set.

This expects there to be exactly two non-zero choices and checks that.

*/

int find_two_digits( /* ARGUMENTS                           */
 int * choices,      /* choices in which to find two digits */
 int * digi1,        /* first digit, set here               */
 int * digi2)        /* second digit, set here              */
{
  const char * name SET_TO "find_two_digits";
  int j;
  int set;

  set SET_TO 0;
  for (j SET_TO 0; j < 9; j++)
    {
      if (choices[j])
	{
	  if (set IS 0)
	    {
	      *digi1 SET_TO j;
	    }
	  else if (set IS 1)
	    {
	      *digi2 SET_TO j;
	    }
	  set++;
	}
    }
  CHB((set ISNT 2), "two digits were not set");
  return OK;
}

/*************************************************************************/

/* init_solve_problem

Returned Value: int
If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. digit_fits returns ERROR

Called By:  main

Side Effects: This alters the choices, sizes, rows, cols, and boxes by
checking what digits can go in what squares and changing the data
appropriately.

The init_world function initializes everything as though any digit
could go in any square. The read_problem changes some data.
After read_problem has executed:
1. For the rows, cols, and boxes:
   a. the value for each digit that was not located is 9.
   b. the value for each digit that was located is 10.
2. For the sizes:
   a. the value for each square that was not filled in is 9.
   b. the value for each square that was filled in is 10.
3. For the choices:
   a. the values for each square that was not filled in are 1 for
      all nine digits.
   b. the values for each square that was filled in are 0 for all
      but the one digit that was used, which has value 1.

*/

int init_solve_problem(       /* ARGUMENTS                    */
 struct sudoku_world * world) /* world model, filled out here */
{
  const char * name SET_TO "init_solve_problem";
  int row;
  int col;
  int digi;
  int fits;

  for (row SET_TO 0; row < 9; row++)
    {
      for (col SET_TO 0; col < 9; col++)
	{
	  if (world->squares[row][col] IS ' ')
	    {
	      for (digi SET_TO 0; digi < 9; digi++)
		{
		  IFF(digit_fits(('1' + digi), row, col, &fits, world));
		  if (NOT fits)
		    {
		      world->choices[row][col][digi] SET_TO 0;
		      world->sizes[row][col]--;
		      if (world->rows[row][digi] ISNT 10)
			{
			  world->rows[row][digi]--;
			}
		      if (world->cols[col][digi] ISNT 10)
			{
			  world->cols[col][digi]--;
			}
		      if (world->boxes[boxFor(row, col)][digi] ISNT 10)
			{
			  world->boxes[boxFor(row, col)][digi]--;
			}
		    }
		}
	    }
	  else
	    {
	      for (digi SET_TO 0; digi < 9; digi++)
		{
		  if (world->rows[row][digi] ISNT 10)
		    {
		      world->rows[row][digi]--;
		    }
		  if (world->cols[col][digi] ISNT 10)
		    {
		      world->cols[col][digi]--;
		    }
		  if (world->boxes[boxFor(row, col)][digi] ISNT 10)
		    {
		      world->boxes[boxFor(row, col)][digi]--;
		    }
		}
	    }
	}
    }
  return OK;
}

/*************************************************************************/

/* init_world

Returned Value: int (OK)

Called By:  main

Side Effects: This sets most ints and chars in the world model and its
components to zero. The squares are all set to blanks.  The choices
are all set to 1. The sizes are all set to 9.  undone is set to 81.

*/

int init_world(               /* ARGUMENTS                     */
 struct sudoku_world * world) /* world model, initialized here */
{
  int n;
  int m;
  int row;
  int col;
  int box;
  int digi;

  world->find_all SET_TO 0;
  for (n SET_TO 0; n < TEXT_SIZE; n++)
    {
      for (m SET_TO 0; m < TEXT_SIZE; m++)
	{
	  world->logic[n][m] SET_TO 0;
	}
    }
  world->logic_line SET_TO 0;
  world->print_all SET_TO 0;
  world->print_choices SET_TO 0;
  world->progress SET_TO 0;
  world->undone SET_TO 81;
  world->verbose SET_TO 0;
  for (row SET_TO 0; row < 9; row++)
    {
      for (col SET_TO 0; col < 9; col++)
	{
	  world->squares[row][col] SET_TO ' ';
	  world->sizes[row][col] SET_TO 9;
	  for (digi SET_TO 0; digi < 9; digi++)
	    {
	      world->choices[row][col][digi] SET_TO 1;
	    }
	}
      for (digi SET_TO 0; digi < 9; digi++)
	{
	  world->rows[row][digi] SET_TO 9;
	}
    }
  for (col SET_TO 0; col < 9; col++)
    {
      for (digi SET_TO 0; digi < 9; digi++)
	{
	  world->cols[col][digi] SET_TO 9;
	}
    }
  for (box SET_TO 0; box < 9; box++)
    {
      for (digi SET_TO 0; digi < 9; digi++)
	{
	  world->boxes[box][digi] SET_TO 9;
	}
    }
  return OK;
}

/*************************************************************************/

/* main

Returned Value: int
If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. read_arguments returns ERROR.
  2. init_world returns ERROR.
  3. init_solve_problem returns ERROR.
  4. read_problem returns ERROR.
  5. solve_problem returns ERROR:
     "Sorry, cannot solve puzzle. It may have 0, 1, or many answers."

Side Effects: This:
1. calls init_world to initialize the world model.
2. calls read_arguments to read the arguments.
3. calls read_problem to read the problem.
4. calls init_solve_problem to initialize the solving process.
5. calls solve_problem to solve the problem.

Notes:

This main follows the model for all mains for solving squares problems.
The model always has the steps listed immediately above (except that
init_solve_problem is optional and may be omitted).

*/

int main(      /* ARGUMENTS                             */
 int argc,     /* one more than the number of arguments */
 char ** argv) /* function name and arguments           */
{
  const char * name SET_TO "main";
  struct sudoku_world world1;
  struct sudoku_world * world;

  world SET_TO &world1;
  IFF(init_world(world));
  IFF(read_arguments(argc, argv, world));
  IFF(read_problem(argv[1], world));
  IFF(init_solve_problem(world));
  if(solve_problem(world) ISNT OK)
    {
      printf("main: Sorry, cannot solve puzzle. "
	     "It may have 0, 1, or many answers.");
      {
	int row;
	int col;
	printf("\n");
	for (row SET_TO 0; row < 9; row++)
	  {
	    for (col SET_TO 0; col < 9; col++)
	      {
		printf("%d ",
		       ((world->sizes[row][col] IS 10) ? 1 :
			world->sizes[row][col]));
	      }
	    printf("\n");
	  }
      }
      return ERROR;
    }
  return OK;
}

/*************************************************************************/

/* print_sudoku

Returned Value: int
If any of the following errors occur, this returns ERROR.
Otherwise, it returns OK.
  1. print_sudoku_with_choices returns ERROR.
  2. print_sudoku_no_choices returns ERROR.

Called By:
  record_progress
  reduce_one
  try_chain_from

Side Effects: The puzzle is printed with or without choices, depending
on the setting of world->print_choices.

*/

int print_sudoku(             /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "print_sudoku";

  if (world->print_choices IS 1)
    IFF(print_sudoku_with_choices(world));
  else
    IFF(print_sudoku_no_choices(world));
  return OK;
}

/*************************************************************************/

/* print_sudoku_no_choices

Returned Value: int (OK)

Called By:
  print_sudoku
  read_problem
  solve_problem

Side Effects: This prints the puzzle from the sudoku_world. The puzzle
is printed with dividing lines (not in the same format as required for
reading in) so the boxes can be seen easily. Digits are printed in those
squares to which digits have been assigned. Other squares are blank.

Example:
-------------------
|  3  |    7|1 5 9|
|5    |    3|  8 7|
|    7|  5  |3 2  |
-------------------
|6   2|9 7  |  3 5|
|  5  |3    |  7  |
|     |5 6 8|2 9 1|
-------------------
|    5|7 3  |9 4 8|
|  9  |4 8  |  1 2|
|4   8|1    |  6 3|
-------------------

*/

int print_sudoku_no_choices(  /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  int row;
  int col;

  printf("\n");
  printf("-------------------\n");
  for (row SET_TO 0; row < 9; row++)
    {
      printf("|");
      for (col SET_TO 0; col < 9; col++)
	{
	  printf("%c", world->squares[row][col]);
	  printf(((col % 3) IS 2) ? "|" : " ");
	}
      printf("\n");
      if ((row % 3) IS 2)
	printf("-------------------\n");
    }
  return OK;
}

/*************************************************************************/

/* print_sudoku_with_choices

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. find_column_width returns ERROR.

Called By:
  print_sudoku
  solve_problem

Side Effects: This prints the puzzle from the sudoku_world. The puzzle
is printed with dividing lines (not in the same format as required for
reading in) so the boxes can be seen easily. Digits are printed in
those squares to which digits have been assigned. All the digits that
might fit are printed in the other squares, enclosed in parentheses.

The strange expression for spaces2 below is based on the fact that if
the column width and the number of non-blank characters to be printed
are both odd or both even, then then number of spaces to print is
even, so half of them can be printed on each side in order to center
the non-blank characters. If the number of spaces is odd, the number
to print before the characters is one less than the number to print
after the characters.

Example (same puzzle as example for print_sudoku_no_choices):
------------------------------------------------------
|(28)    3     (46) |(268)  (24)    7   |  1   5  9  |
|  5   (1246) (1469)|(26)  (1249)   3   |(46)  8  7  |
|(189) (1468)   7   |(68)    5    (1469)|  3   2 (46)|
------------------------------------------------------
|  6   (148)    2   |  9     7     (14) |(48)  3  5  |
|(189)   5    (149) |  3   (124)  (124) |(468) 7 (46)|
|(37)   (47)   (34) |  5     6      8   |  2   9  1  |
------------------------------------------------------
|(12)  (126)    5   |  7     3     (26) |  9   4  8  |
|(37)    9     (36) |  4     8     (56) |(57)  1  2  |
|  4    (27)    8   |  1    (29)  (259) |(57)  6  3  |
------------------------------------------------------

*/

int print_sudoku_with_choices( /* ARGUMENTS   */
 struct sudoku_world * world)  /* world model */
{
  const char * name SET_TO "print_sudoku_with_choices";
  int row;
  int col;
  int widths[9];
  int n;
  int dash_length;
  char dashes[TEXT_SIZE];
  int spaces1;
  int spaces2;

  for (col SET_TO 0; col < 9; col++)
    {
      IFF(find_column_width(col, (widths + col), world));
    }
  dash_length SET_TO 10;
  for (col SET_TO 0; col < 9; col++)
    {
      dash_length SET_TO (dash_length + widths[col]);
    }
  for (n SET_TO 0; n < dash_length; n++)
    {
      dashes[n] SET_TO '-';
    }
  dashes[dash_length] SET_TO 0;
  printf("\n");
  printf("%s\n", dashes);
  for (row SET_TO 0; row < 9; row++)
    {
      printf("|");
      for (col SET_TO 0; col < 9; col++)
	{
	  if (world->squares[row][col] IS ' ')
	    { 
	      spaces1 SET_TO ((widths[col] - (world->sizes[row][col] + 2)) / 2);
	      spaces2 SET_TO (((widths[col] %2) IS (world->sizes[row][col] %2))
			      ? spaces1 : (spaces1 + 1));
	      for (n SET_TO 0; n < spaces1; n++)
		putchar(' ');
	      putchar('(');
	      for (n SET_TO 0; n < 9; n++)
		{
		  if (world->choices[row][col][n])
		    putchar('1' + n);
		}
	      putchar(')');
	      for (n SET_TO 0; n < spaces2; n++)
		putchar(' ');
	      printf(((col % 3) IS 2) ? "|" : " ");
	    }
	  else
	    {
	      spaces1 SET_TO ((widths[col] - 1) / 2);
	      spaces2 SET_TO ((widths[col] % 2) ? spaces1 : (spaces1 + 1));
	      for (n SET_TO 0; n < spaces1; n++)
		putchar(' ');
	      printf("%c", world->squares[row][col]);
	      for (n SET_TO 0; n < spaces2; n++)
		putchar(' ');
	      printf(((col % 3) IS 2) ? "|" : " ");
	    }
	}
      printf("\n");
      if ((row % 3) IS 2)
	printf("%s\n", dashes);
    }

  return OK;
}

/*************************************************************************/

/* read_arguments

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. argc is not 4 or 5.
  2. argv[2] is not "all" or "one.
  3. argv[3] is not "yes" or "no".
  4. argc is 5 and argv[4] is not "v".

Called By:  main

Side Effects: If there is no error, the values of world->find_all,
world->print_all, and world->verbose are set. If there is an error,
a message is printed explaining how to call the executable.

Notes:

The executable compiled from this code is expected but not required to
be named sudoku.  The way to call the executable and what the
arguments may be are explained in the function.

*/

int read_arguments(           /* ARGUMENTS                             */
 int argc,                    /* one more than the number of arguments */
 char ** argv,                /* function name and arguments           */
 struct sudoku_world * world) /* world model                           */
{
  const char * name SET_TO "read_arguments";

  if (((argc IS 4) OR ((argc IS 5) AND (strcmp(argv[4], "v") IS 0))) AND
      ((strcmp(argv[2], "all") IS 0) OR (strcmp(argv[2], "one") IS 0)) AND
      ((strcmp(argv[3], "no") IS 0) OR (strcmp(argv[3], "yes") IS 0)))
    {
      if (strcmp(argv[2], "all") IS 0)
	world->find_all SET_TO 1;
      else
	world->find_all SET_TO 0;
      if (strcmp(argv[3], "yes") IS 0)
	world->print_all SET_TO 1;
      else
	world->print_all SET_TO 0;
      if (argc IS 5)
	world->verbose SET_TO 1;
      else
	world->verbose SET_TO 0;
    }
  else
    {
      printf("Usage: %s <file name> <all|one> <yes|no> [v]\n", argv[0]);
      printf("all = find all solutions\n");
      printf("one = find one solution\n");
      printf("yes = print puzzle when done and when a rule makes progress\n");
      printf("no = print puzzle only when done\n");
      printf("v = verbose (prints more messages)\n");
      CHB(1, " ");
    }
  return OK;
}

/*************************************************************************/

/* read_problem

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. The named file cannot be opened: "Could not open file".
  2. The file ends before the first blank line:
     "File ends before first blank line".
  3. The file has fewer than 9 lines of data:
     "File has fewer than 9 lines of data".
  4. A line does not have 10 characters (the 10th is a newline):
     "Line does not have 9 characters".
  5. A character before the newline is not a blank or digit from 1 to 9:
     "Bad character read".
  6. digit_fits returns ERROR.
  7. A character does not fit where it is supposed to go:
     "Character does not fit; puzzle has no solution"
  8. print_sudoku_no_choices returns ERROR.

Called By:  main

Side Effects: The puzzle in the file named file_name is read and stored
in the "squares" array of the world model. Also, the choices and sizes
are modified.

Notes:

The file being read represents a 9 by 9 array of squares. Each square
is to be filled with a digit between 1 and 9. Some of the squares are
already filled in. The file must have all of the following in the
order given:

1. a blank line (above which everything is read and ignored).
2. 9 rows of 9 characters each (after which reading stops).
   Each character must be a blank or a digit from 1 to 9.

Here is a sample file between rows of stars.
The first and last of the 9 rows are blank, but each contains 9 blanks.
The second row is blank (has nothing but a newline).

****************************************************
This is a comment

         
    2 184
9 5 7 2 6
1 4392 7 
   7 6   
 7 1489 2
3 2 6 8 5
849 3    
         
****************************************************

The reading procedure is:
1. Open the file and check that it opened.
2. Look for a blank line. Read and ignore everything before the blank line.
3. Read the rows.
4. Close the file.
5. If print_all is not zero, print the puzzle and a progress message.

Anything before the first blank line is a header which is intended to
contain explanatory text, but could be anything.

In reading a row, each digit is tested to see if it fits in the col
where it is supposed to go. If so:
1. the digit is put into squares[row][col].
2. sizes[row][col] is set to 10, indicating that only one digit can go
   there and it has been recorded in the squares array.
3. all choices for that square are set to zero, except that
   choices[row][col][digit - '1'] is set to 1. This may not be necessary.
4. rows[row][digit - '1'] is set to 10
5. cols[col][digit - '1'] is set to 10.
6. boxes[box][digit - '1'] is set to 10.

Other entries in rows, cols, and boxes are not modified, although they
could be. The other entries are modified correctly in init_solve_problem.

*/

int read_problem(             /* ARGUMENTS                  */
 char * file_name,            /* name of file to read       */
 struct sudoku_world * world) /* world model, modified here */
{
  const char * name SET_TO "read_problem";
  FILE * in_port;
  char buffer[TEXT_SIZE];
  int row;
  int col;
  char digit;
  int fits;
  int num;

  in_port SET_TO fopen(file_name, "rb");
  CHB((in_port IS NULL), "Could not open file");
  for (; ; )
    {
      CHB((fgets(buffer, TEXT_SIZE, in_port) IS NULL),
	  "File ends before first blank line");
      if (buffer[0] IS '\n')
	break;
      else if ((buffer[0] IS 13) AND (buffer[1] IS 10))
	break;
    }
  for (row SET_TO 0; row < 9; row++)
    {
      CHB((fgets(buffer, TEXT_SIZE, in_port) IS NULL),
	  "File has fewer than 9 lines of data");
      CHB(((strlen(buffer) ISNT 10) AND (strlen(buffer) ISNT 11)),
	  "Line does not have 9 characters");
      CHB(((strlen(buffer) IS 10) AND (buffer[9] ISNT '\n')),
	  "Line does not have 9 characters");
      CHB(((strlen(buffer) IS 11) AND 
	   ((buffer[9] ISNT 13) OR (buffer[10] ISNT 10))),
	  "Line does not have 9 characters");
      for (col SET_TO 0; col < 9; col++)
	{
	  digit SET_TO buffer[col];
	  if (digit ISNT ' ')
	    {
	      CHB(((digit < '1') OR (digit > '9')), "Bad character read");
	      IFF(digit_fits(digit, row, col, &fits, world));
	      CHB((NOT fits),
		  "Character does not fit; puzzle has no solution");
	      world->squares[row][col] SET_TO digit;
	      world->undone--;
	      world->sizes[row][col] SET_TO 10;
	      for (num SET_TO 0; num < 9; num++)
		{
		  if (digit IS ('1' + num))
		    {
		      world->choices[row][col][num] SET_TO 1;
		      world->rows[row][num] SET_TO 10;
		      world->cols[col][num] SET_TO 10;
		      world->boxes[boxFor(row, col)][num] SET_TO 10;
		    }
		  else
		    world->choices[row][col][num] SET_TO 0;
		}
	    }
	}
    }
  fclose(in_port);
  strcpy(world->logic[world->logic_line++], "read problem");
  if (world->print_all)
    {
      IFF(print_sudoku_no_choices(world));
      printf("%s\n\n", world->logic[world->logic_line - 1]);
    }
  return OK;
}

/*************************************************************************/

/* record_progress

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. print_sudoku returns ERROR.

Called By:
  try_box_one
  try_box_same_rc
  try_box_three
  try_box_two
  try_chain_from
  try_col_one
  try_col_same_box
  try_col_three
  try_col_two
  try_col_Xwing
  try_no_choice_from
  try_row_one
  try_row_same_box
  try_row_three
  try_row_two
  try_row_Xwing
  try_square_one
  try_stack_digi
  try_tier_digi

Side Effects: If progress has been made, a line of explanation is
recorded, and if world->print_all is non-zero, the puzzle is printed
followed by an explanation of how progress was made.

*/

int record_progress(          /* ARGUMENTS                       */
 char * message,              /* text giving action and reason   */
 struct sudoku_world * world) /* world model                     */
{
  const char * name SET_TO "record_progress";

  if (world->progress ISNT 0)
    {
      sprintf(world->logic[world->logic_line], "%s", message);
      if (world->print_all)
	{
	  IFF(print_sudoku(world));
	  printf("%s\n\n", world->logic[world->logic_line]);
	}
      world->logic_line++;
    }
  return OK;
}

/*************************************************************************/

/* reduce_boxes

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. delete_choice returns ERROR.
  2. the number of places the digit with the given index can fit after
     the extra choices are removed is not exactly 1:
     "Puzzle has no answer."

Called By:
  try_chain_from
  try_col_one
  try_row_one
  try_square_one

Side Effects: 

The digit with the given index has just been placed in the square at
row and col. This checks the box for the given row and col to see if
the digit would have fit in some other square of the box at row i and
column j. If so, that fit is eliminated and:
1. The number of places the digit fits in row i is reduced by 1.
2. The number of places the digit fits in column j is reduced by 1.
3. The number of places the digit fits in the box containing the
   square is reduced by 1.

This process should reduce the number of places the digit might fit in
the given box to 1. That is checked. Then that number of places is
set to 10 to indicate that the digit has been located.

This will examine only four squares in the box, since the other five
squares have already been handled.

*/

int reduce_boxes(      /* ARGUMENTS                     */
 int row,              /* row in which digit placed     */
 int col,              /* column in which digit placed  */
 int digi,             /* index of placed digit         */
 sudoku_world * world) /* world model                   */
{
  const char * name SET_TO "reduce_boxes";
  int i;      /* index for rows */
  int j;      /* index for columns */
  int start_i;
  int start_j;

  start_i SET_TO ((row / 3) * 3);
  start_j SET_TO ((col / 3) * 3);
  for (i SET_TO start_i; i < (start_i + 3); i++)
    {
      if (i IS row)
	continue;
      for (j SET_TO start_j; j < (start_j + 3); j++)
	{
	  if (j IS col)
	    continue;
	  if (world->choices[i][j][digi] IS 1)
	    {
	      IFF(delete_choice(i, j, digi, 1, world));
	    }
	}
    }
  CHB((world->boxes[boxFor(row, col)][digi] ISNT 1), "Puzzle has no answer.");
  world->boxes[boxFor(row, col)][digi] SET_TO 10;
  return OK;
}

/*************************************************************************/

/* reduce_box_three

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. find_box_row_col returns error.
  2. reduce_one returns error.

Called By: try_box_three

Side Effects: 

The three digits with the given indexes (digi1, digi2, and digi3) are
known to go in the three squares (at [row1,col1], [row2, col2] and
[row3,col3]). This checks the given box to see if the digit would have
fit in some other square [i,j] of the box. If so, that fit is
eliminated and reduce_one is called so that:
1. The number of places the digit fits in row i is reduced by 1.
2. The number of places the digit fits in column j is reduced by 1.
3. The number of places the digit fits in the box containing the
   square is reduced by 1.

*/

int reduce_box_three(         /* ARGUMENTS              */
 int box,                     /* box in which to reduce */
 int row1,                    /* row of digi1           */
 int row2,                    /* row of digi2           */
 int row3,                    /* row of digi3           */
 int col1,                    /* column of digi1        */
 int col2,                    /* column of digi2        */
 int col3,                    /* column of digi3        */
 int digi1,                   /* index of first digit   */
 int digi2,                   /* index of second digit  */
 int digi3,                   /* index of third digit   */
 struct sudoku_world * world) /* world model            */
{
  const char * name SET_TO "reduce_box_three";
  int place;
  int row;
  int col;
  
  for (place SET_TO 0; place < 9; place++)
    {
      IFF(find_box_row_col(box, place, &row, &col));
      if (NOT (((row IS row1) AND (col IS col1)) OR
	       ((row IS row2) AND (col IS col2)) OR
	       ((row IS row3) AND (col IS col3))))
	{
	  IFF(reduce_one(row, col, digi1, NULL, 1, world));
	  IFF(reduce_one(row, col, digi2, NULL, 1, world));
	  IFF(reduce_one(row, col, digi3, NULL, 1, world));
	}
    }
  return OK;
}

/*************************************************************************/

/* reduce_col_three
FIX - documentation done to here
Returned Value: int

Called By:

*/

int reduce_col_three(           /* ARGUMENTS   */
 int col,
 int row1,
 int row2,
 int row3,
 int digi1,
 int digi2,
 int digi3,
 int * reduced,
 struct sudoku_world * world) /* world model                     */
{
  const char * name SET_TO "reduce_col_three";
  int i;

  for (i SET_TO 0; i < 9; i++)
    {
      if ((i ISNT row1) AND (i ISNT row2) AND (i ISNT row3))
	{
	  IFF(reduce_one(i, col, digi1, reduced, 1, world));
	  IFF(reduce_one(i, col, digi2, reduced, 1, world));
	  IFF(reduce_one(i, col, digi3, reduced, 1, world));
	}
    }
  return OK;
}

/*************************************************************************/

/* reduce_cols

Returned Value: int

Called By:
  try_box_one
  try_col_one
  try_square_one

The digit with the given index has just been placed in the square at
row and col. This checks the given row to see if the digit would have
fit in that row and each of the other columns. If so, that fit is
eliminated and:
1. The number of places the digit fits in the row is reduced by 1.
2. The number of places the digit fits in that column is reduced by 1.
3. The number of places the digit fits in the box containing the
   square is reduced by 1.

This process should reduce the number of places the digit might fit in
the given row to 1. That is checked. Then that number of places is
set to 10 to indicate that the digit has been located.

*/

int reduce_cols(       /* ARGUMENTS                   */
 int row,              /* row in which digi placed    */
 int col,              /* column in which digi placed */
 int digi,             /* index of the placed digit   */
 sudoku_world * world) /* world model                 */
{
  const char * name SET_TO "reduce_cols";
  int j;       /* index for columns */

  for(j SET_TO 0; j < 9; j++)
    {
      if ((j ISNT col) AND (world->choices[row][j][digi] IS 1))
	{
	  IFF(delete_choice(row, j, digi, 1, world));
	}
    }
  CHB((world->rows[row][digi] ISNT 1), "Puzzle has no answer.");
  world->rows[row][digi] SET_TO 10;
  return OK;
}

/*************************************************************************/

/* reduce_one

Called By:
 reduce_box_three
 reduce_col_three
 reduce_row_three
 try_box_two
 try_col_two
 try_row_two

First, if the puzzle has not previously been printed showing choices
(indicated by world->print_choices being zero), the puzzle is printed
showing choices and the indicator is set to 1.

Next, if world->choices[row][col][digi] is 1 (meaning that the digit
with the given index is currently a possible choice in the given row
and column):

a. That choice is removed.

b. If the "reduced" array isn't NULL, this records in the reduced array
   the row (if isRow is 1) or column (if isRow is 0) in which a choice
   was deleted.

*/

int reduce_one(               /* ARGUMENTS */
 int row,
 int col,
 int digi,
 int * reduced,
 int isRow,                   /* flag: 1=reduced indexed by row, 0=by col */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "reduce_one";
  if (world->choices[row][col][digi])
    {
      if (world->print_choices IS 0)
	{
	  world->print_choices SET_TO 1;
	  IFF(print_sudoku(world));
	}
      IFF(delete_choice(row, col, digi, 1, world));
      world->progress SET_TO 1;
      if (reduced)
	reduced[isRow ? row : col] SET_TO 1;
    }
  return OK;
}

/*************************************************************************/

int reduce_row_three(         /* ARGUMENTS */
 int row,
 int col1,
 int col2,
 int col3,
 int digi1,
 int digi2,
 int digi3,
 int * reduced,
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "reduce_row_three";
  int j;

  for (j SET_TO 0; j < 9; j++)
    {
      if ((j ISNT col1) AND (j ISNT col2) AND (j ISNT col3))
	{
	  IFF(reduce_one(row, j, digi1, reduced, 0, world));
	  IFF(reduce_one(row, j, digi2, reduced, 0, world));
	  IFF(reduce_one(row, j, digi3, reduced, 0, world));
	}
    }
  return OK;
}

/*************************************************************************/

/* reduce_rows

Called By:
  try_box_one
  try_row_one
  try_square_one

The digit with the given index has just been placed in the square at
row and col. This checks the given column to see if the digit would have
fit in that column and each of the other rows. If so, that fit is
eliminated and:
1. The number of places the digit fits in that row is reduced by 1.
2. The number of places the digit fits in the column is reduced by 1.
3. The number of places the digit fits in the box containing the
   square is reduced by 1.

This process should reduce the number of places the digit might fit in
the given column to 1. That is checked. Then that number of places is
set to 10 to indicate that the digit has been located.

*/

int reduce_rows(       /* ARGUMENTS                   */
 int row,              /* row in which digi placed    */
 int col,              /* column in which digi placed */
 int digi,             /* index of the placed digit   */
 sudoku_world * world) /* world model                 */
{
  const char * name SET_TO "reduce_rows";
  int i;       /* index for rows */

  for(i SET_TO 0; i < 9; i++)
    {
      if ((i ISNT row) AND (world->choices[i][col][digi] IS 1))
	{
	  delete_choice(i, col, digi, 1, world);
	}
    }
  CHB((world->cols[col][digi] ISNT 1), "Puzzle has no answer.");
  world->cols[col][digi] SET_TO 10;
  return OK;
}

/*************************************************************************/

/* run_round

This is running the following two simple strategies through one round:
1. only one choice for a square.
2. digit fits only one place in row, column, or box.

If only strategy 1 is implemented, some puzzles are not solved that
are solved if both are implemented (e.g. au_1)

The results of the updating are dependent on the order of updating,
but the values saved for choices still make it possible to backtrack
and find the chain of causality.

In setting digi, when the size for a square is 1, only one of the
choices should be greater than 0 but less than 10, and its value
should be 1. This is checked during the process of finding digi.

The marking of choices is done so as to make it possible to determine
which row and column with size 1 forced a choice to be deleted.  This
is done by the use of row_factor, which is always a power of 100.
col_factor is set to row_factor/10. On successive rounds, factor is
multiplied (in try_chain_from) by 100. The value for a choice to be
removed is set to 
(((row + 1) * row_factor) + ((col + 1) * col_factor) + 0to3).
The row, column and round can then be identified from the number. For
example, if the number is 230, the choice was deleted on the first
round when the square at [2,3] had size 1. If the number is 74000, the
choice was deleted on the second round when the square at [7,4] had
size 1. In addition, if the digit fits only one place in a row, column,
or box, 1 is added if it is a row, 2 is added if it is a column,
and 3 is added if it is a box.

Using the markings, chains can be traced backwards from a key square
(one that has no choices in an environment or one choice that is
forced to be the same in the two environments). Tracing backwards is
not currently implemented.

This makes sure the size for a square is never made negative.

*/

int run_round(                /* ARGUMENTS                       */
 int choices[9][9][9],        /* choices for each square         */
 int sizes1[9][9],            /* size of choices for each square */
 int row_factor,              /* row factor for marking choices  */
 struct sudoku_world * world) /* world model (needed by IFF)     */
{
  const char * name SET_TO "run_round";
  int row;
  int col;
  int box;
  int i;
  int j;
  int k;
  int place;
  int digi;
  int col_factor;
  int size;

  col_factor SET_TO (row_factor / 10);
  for (row SET_TO 0; row < 9; row++)
    {
      for (col SET_TO 0; col < 9; col++)
	{
	  if (sizes1[row][col] IS 1)
	    {
	      sizes1[row][col] SET_TO 10;
	      digi SET_TO -1;
	      for (k SET_TO 0; k < 9; k++)
		{
		  if (choices[row][col][k] IS 1)
		    {
		      CHB((digi ISNT -1), "Bug 1 from run_round");
		      digi SET_TO k;
		    }
		  else
		    {
		      CHB(((choices[row][col][k] < 10) AND
			   (choices[row][col][k] > 0)), "Bug 2 from run_round");
		    }
		}
	      for (j SET_TO 0; j < 9; j++)
		{ // process rest of row
		  if ((j ISNT col) AND (choices[row][j][digi] IS 1) AND
		      (sizes1[row][j] > 0))
		    {
		      choices[row][j][digi] SET_TO
			(((row + 1) * row_factor) + ((col + 1) * col_factor));
		      sizes1[row][j]--;
		    }
		}
	      for (i SET_TO 0; i < 9; i++)
		{ // process rest of column
		  if ((i ISNT row) AND (choices[i][col][digi] IS 1) AND
		      (sizes1[i][col] > 0))
		    {
		      choices[i][col][digi] SET_TO
			(((row + 1) * row_factor) + ((col + 1) * col_factor));
		      sizes1[i][col]--;
		    }
		}
	      for (place SET_TO 0; place < 9; place++)
		{ // process rest of box
		  IFF(find_box_row_col(boxFor(row, col), place, &i, &j));
		  if ((i ISNT row) AND (j ISNT col) AND
		      (choices[i][j][digi] IS 1) AND (sizes1[i][j] > 0))
		    {
		      choices[i][j][digi] SET_TO
			(((row + 1) * row_factor) + ((col + 1) * col_factor));
		      sizes1[i][j]--;
		    }
		}
	    }
	  else if (sizes1[row][col] IS 0)
	    {
	      size SET_TO 0;
	      digi SET_TO 0;
	      for (k SET_TO 0; k < 9; k++)
		{
		  if (choices[row][col][k] > size)
		    {
		      size SET_TO choices[row][col][k];
		      digi SET_TO k;
		    }
		}
	      sizes1[row][col] SET_TO 10;
	      choices[row][col][digi] SET_TO 1;
	    }
	}
    }
  for (digi SET_TO 0; digi < 9; digi++)
    {
      for (row SET_TO 0; row < 9; row++)
	{
	  size SET_TO 0;
	  for (col SET_TO 0; col < 9; col++)
	    {
	      if (choices[row][col][digi] IS 1)
		{
		  size++;
		  j SET_TO col;
		}
	    }
	  if ((size IS 1) AND (sizes1[row][j] < 10))
	    {
	      col SET_TO j;
	      sizes1[row][col] SET_TO 1;
	      for (k SET_TO 0; k < 9; k++)
		{ // remove other choices from square
		  if ((k ISNT digi) AND (choices[row][col][k] IS 1))
		    {
		      choices[row][col][k] SET_TO
			(((row + 1) * row_factor) + ((col + 1) * col_factor));
		    }
		}
	    }
	}
      for (col SET_TO 0; col < 9; col++)
	{
	  size SET_TO 0;
	  for (row SET_TO 0; row < 9; row++)
	    {
	      if (choices[row][col][digi] IS 1)
		{
		  size++;
		  i SET_TO row;
		}
	    }
	  if ((size IS 1) AND (sizes1[i][col] < 10))
	    {
	      row SET_TO i;
	      sizes1[row][col] SET_TO 1;
	      for (k SET_TO 0; k < 9; k++)
		{ // remove other choices from square
		  if ((k ISNT digi) AND (choices[row][col][k] IS 1))
		    {
		      choices[row][col][k] SET_TO
			(((row + 1) * row_factor) + ((col + 1) * col_factor));
		    }
		}
	    }
	}
      for (box SET_TO 0; box < 9; box++)
	{
	  size SET_TO 0;
	  for (place SET_TO 0; place < 9; place++)
	    {
	      IFF(find_box_row_col(box, place, &i, &j));
	      if (choices[i][j][digi] IS 1)
		{
		  size++;
		  row SET_TO i;
		  col SET_TO j;
		}
	    }
	  if ((size IS 1) AND (sizes1[row][col] < 10))
	    {
	      sizes1[row][col] SET_TO 1;
	      for (k SET_TO 0; k < 9; k++)
		{ // remove other choices from square
		  if ((k ISNT digi) AND (choices[row][col][k] IS 1))
		    {
		      choices[row][col][k] SET_TO
			(((row + 1) * row_factor) + ((col + 1) * col_factor));
		    }
		}
	    }
	}
    }
  return OK;
}

/*************************************************************************/

/* solve_problem

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. try_square_one returns ERROR.
  2. try_row_one returns ERROR.
  3. try_col_one returns ERROR.
  4. try_box_one returns ERROR.
  5. try_row_two returns ERROR.
  6. try_col_two returns ERROR.
  7. try_box_two returns ERROR.
  8. print_sudoku_no_choices returns ERROR.
  9. print_sudoku_with_choices returns ERROR.
 10. explain_sudoku returns ERROR.
 11. The system is unable to solve the problem.

Called By:
  main

Side Effects: The puzzle gets filled in, if possible. While this is
happening, the sudoku_world gets changed continually.

Notes:

This has a hard-coded list of things to try for solving
the puzzle arranged in order from easy to hard:

1.  try_square_one (only one digit fits in square)
2.  try_row_one (digit fits only one place in row)
3.  try_col_one (digit fits only one place in column)
4.  try_box_one (digit fits only one place in box)
5.  try_row_two (only two digits fit in two places in row)
6.  try_col_one (only two digits fit in two places in column)
7.  try_box_one (only two digits fit in two places in box)

The first four are actually all about equally easy.

The function goes down the list of things to try. As soon as one of
the functions succeeds in filling in even one square, solve_problem
goes back to the top of the list (skipping the remaining, harder,
things to try) and goes down it again. The easier things to try (even
the same thing that worked last time) may now work because more of the
puzzle is filled in.

*/

int solve_problem(            /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "solve_problem";

  for (world->progress SET_TO 1; ((world->undone ISNT 0) AND world->progress); )
    {
      world->progress SET_TO 0;
      IFF(try_square_one(world));
      if (world->progress)
	continue;
      IFF(try_row_one(world));
      if (world->progress)
	continue;
      IFF(try_col_one(world));
      if (world->progress)
	continue;
      IFF(try_box_one(world));
      if (world->progress)
	continue;
      IFF(try_row_two(world));
      if (world->progress)
	continue;
      IFF(try_col_two(world));
      if (world->progress)
	continue;
      IFF(try_box_two(world));
      if (world->progress)
	continue;
      IFF(try_row_three(world));
      if (world->progress)
	continue;
      IFF(try_col_three(world));
      if (world->progress)
	continue;
      IFF(try_box_three(world));
      if (world->progress)
	continue;
      IFF(try_row_same_box(world));
      if (world->progress)
	continue;
      IFF(try_col_same_box(world));
      if (world->progress)
	continue;
      IFF(try_box_same_rc(world));
      if (world->progress)
	continue;
      IFF(try_row_Xwing(world));
      if (world->progress)
	continue;
      IFF(try_col_Xwing(world));
      if (world->progress)
	continue;
      IFF(try_box_box_row(world));
      if (world->progress)
	continue;
      IFF(try_box_box_col(world));
      if (world->progress)
	continue;
      IFF(try_chain(world));
      if (world->progress)
	continue;
      IFF(try_no_choice(world));
      if (world->progress)
	continue;
    }
  if (world->undone IS 0)
    {
      IFF(print_sudoku_no_choices(world));
      IFF(explain_sudoku(world));
    }
  else
    {
      print_sudoku_with_choices(world);
    }
  return ((world->undone IS 0) ? OK : ERROR);
}

/*************************************************************************/

/* try_box_box_col

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. try_stack_digi returns ERROR.
  

Called By: solve_problem

A stack is a column of boxes.

*/

int try_box_box_col(          /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_box_box_col";
  int digi;
  int stack;

  for (digi SET_TO 0; ((digi < 9) AND (NOT world->progress)); digi++)
    {
      for (stack SET_TO 0; ((stack < 3) AND (NOT world->progress)); stack++)
	{
	  IFF(try_stack_digi(stack, digi, world));
	}
    }
  return OK;
}

/*************************************************************************/

/* try_box_box_row

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. try_tier_digi returns ERROR.
  

Called By: solve_problem

A tier is a row of boxes.

*/

int try_box_box_row(          /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_box_box_row";
  int digi;
  int tier;

  for (digi SET_TO 0; ((digi < 9) AND (NOT world->progress)); digi++)
    {
      for (tier SET_TO 0; ((tier < 3) AND (NOT world->progress)); tier++)
	{
	  IFF(try_tier_digi(tier, digi, world));
	}
    }
  return OK;
}

/*************************************************************************/

/* try_box_one

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. record_progress returns ERROR.
  2. 

Called By:  solve_problem

Side Effects: 

This writes a progress message of the following form:
"Put 1 at [5,2]; it fits nowhere else in that box."

*/

int try_box_one(              /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_box_one";
  int row;
  int col;
  int box;
  int digi;
  int place;
  int k;
  char message[TEXT_SIZE];

  row SET_TO -1;
  for (box SET_TO 0; box < 9; box++)
    {
      for (digi SET_TO 0; digi < 9; digi++)
	{
	  if (world->boxes[box][digi] IS 1)
	    {
	      for (place SET_TO 0; place < 9; place++)
		{
		  IFF(find_box_row_col(box, place, &row, &col));
		  if (world->choices[row][col][digi] IS 1)
		    {
		      break;
		    }
		}
	      CHB((place IS 9), "Bug found during call to try_box_one");
	      world->squares[row][col] SET_TO ('1' + digi);
	      world->sizes[row][col] SET_TO 10;
	      world->boxes[box][digi] SET_TO 10;
	      for (k SET_TO 0; k < 9; k++)
		{
		  if ((k ISNT digi) AND (world->choices[row][col][k] IS 1))
		    {
		      delete_choice(row, col, k, 0, world);
		    }
		}
	      reduce_cols(row, col, digi, world);
	      reduce_rows(row, col, digi, world);
	      world->undone--;
	      world->progress SET_TO 1;
	      sprintf(message, "Put %d at [%d,%d]; "
		      "it fits nowhere else in that box.",
		      (digi + 1), (row + 1), (col + 1));
	      IFF(record_progress(message, world));
	      break;
	    }
	}
      if (row ISNT -1)
	break;
    }
  return OK;
}

/*************************************************************************/

/* try_box_same_rc

If a given digit fits only two or three places in a box, and those two
or three places are in the same row or column, then that digit cannot
go elsewhere in the row or column.

For example, in the following, 2 can be eliminated elsewhere on the
middle line.

    |---------------|
    |   4     8   9 |
    | (123) (123) 6 |
    |   5    (13) 7 |
    |---------------|

*/

int try_box_same_rc(          /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_box_same_rc";
  int box;
  int digi;
  int row;
  int col;
  int row1;
  int col1;
  int row2;
  int col2;
  int row3;
  int col3;
  int reduced[9];
  int k;            /* index for message  */
  int j;            /* index for reduced  */
  char message[TEXT_SIZE];

  for (box SET_TO 0; ((box < 9) AND (NOT world->progress)); box++)
    {
      for (digi SET_TO 0; ((digi < 9) AND (NOT world->progress)); digi++)
	{
	  if ((world->boxes[box][digi] IS 2) OR
	      (world->boxes[box][digi] IS 3))
	    {
	      IFF(find_digit_in_box(box, digi, 1, &row1, &col1, world));
	      IFF(find_digit_in_box(box, digi, 2, &row2, &col2, world));
	      if (world->boxes[box][digi] IS 3)
		IFF(find_digit_in_box(box, digi, 3, &row3, &col3, world));
	      else
		{
		  row3 SET_TO row1;
		  col3 SET_TO col1;
		}
	      if ((row1 IS row2) AND (row1 IS row3))
		{
		  for (j SET_TO 0; j < 9; j++)
		    reduced[j] SET_TO 0;
		  for (col SET_TO 0; col < 9; col++)
		    {
		      if ((col ISNT col1) AND
			  (col ISNT col2) AND
			  (col ISNT col3))
			{
			  IFF(reduce_one(row1, col, digi, reduced, 0, world));
			}
		    }
		  if (world->progress)
		    {
		      k SET_TO sprintf(message, "In box %d, digit %d fits only "
				       "in row %d and columns %d ", (box + 1),
				       (digi + 1), (row1 + 1), (col1 + 1));
		      if (world->boxes[box][digi] IS 2)
			{
			  k SET_TO (k + sprintf((message + k), "and %d.\n",
						(col2 + 1)));
			}
		      else // if (world->boxes[box][digi] IS 3)
			{
			  k SET_TO (k + sprintf((message + k), "%d and %d.\n",
						(col2 + 1), (col3 + 1)));
			}
		      k SET_TO (k + sprintf((message + k), 
					    "  Remove %d from the choices "
					    "in columns", (digi + 1)));
		    }
		}
	      else if ((col1 IS col2) AND (col1 IS col3))
		{
		  for (j SET_TO 0; j < 9; j++)
		    reduced[j] SET_TO 0;
		  for (row SET_TO 0; row < 9; row++)
		    {
		      if ((row ISNT row1) AND
			  (row ISNT row2) AND
			  (row ISNT row3))
			{
			  IFF(reduce_one(row, col1, digi, reduced, 1, world));
			}
		    }
		  if (world->progress)
		    {
		      k SET_TO sprintf(message, "In box %d, digit %d fits only "
				       "in column %d and rows %d ", (box + 1),
				       (digi + 1), (col1 + 1), (row1 + 1));
		      if (world->boxes[box][digi] IS 2)
			{
			  k SET_TO (k + sprintf((message + k), "and %d.\n",
						(row2 + 1)));
			}
		      else // if (world->boxes[box][digi] IS 3)
			{
			  k SET_TO (k + sprintf((message + k), "%d and %d.\n",
						(row2 + 1), (row3 + 1)));
			}
		      k SET_TO (k + sprintf((message + k),
					    "  Remove %d from the choices "
					    "in rows", (digi + 1)));
		    }
		}
	      if (world->progress)
		{
		  for (j SET_TO 0; j < 9; j++)
		    {
		      if (reduced[j])
			{
			  message[k++] SET_TO (' ');
			  message[k++] SET_TO ('1' + j);
			}
		    }
		  message[k++] SET_TO '.';
		  message[k] SET_TO 0;
		  IFF(record_progress(message, world));
		}
	    }
	}
    }
  return OK;
}

/*************************************************************************/

/* try_box_three

Returned Value: int
  If any of the following errors occurs, this returns ERROR.
  Otherwise, it returns OK.
  1. find_box_row_col returns ERROR.
  2. reduce_box_three returns ERROR.
  3. find_three_box_3_3_3 returns ERROR.
  4. find_three_box_3_3_2 returns ERROR.
  5. find_three_box_3_2_2 returns ERROR.
  6. find_three_box_2_2_2 returns ERROR.

Called By: solve_problem

If a digit must go in one of three places in a box, it is removed from
other choices in the box. There are four possible patterns for fitting
three ways:
(123)(123)(123)
(123)(123)(12)
(123)(13)(12)
(23)(13)(12)

example (from post_060224.pro)

------------------------
| (479)     3    (479) |
|  (67)   (567)    8   |
|   2     (567)    1   |
------------------------

Digit 7 must go in (67), (567), or (567), so it is removed from each of
the (479)s.

*/

int try_box_three(            /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_box_three";
  int box;
  int place;
  int row1;
  int row2;
  int row3;
  int col1;
  int col2;
  int col3;
  int digi1;
  int digi2;
  int digi3;
  char message[TEXT_SIZE];

  for (box SET_TO 0; ((box < 9) AND (NOT world->progress)); box++)
    {
      for (place SET_TO 0; ((place < 9) AND (NOT world->progress)); place++)
	{
	  IFF(find_box_row_col(box, place, &row1, &col1));
	  if (world->sizes[row1][col1] IS 3)
	    {
	      digi3 SET_TO -1;
	      IFF(find_three_box_3_3_3(box, place, row1, col1, &row2, &row3,
				       &col2, &col3, &digi1, &digi2, &digi3,
				       world));
	      if (digi3 ISNT -1)
		{
		  IFF(reduce_box_three(box, row1, row2, row3, col1, col2,
				       col3, digi1, digi2, digi3, world));
		}
	      if (world->progress)
		break;
	      digi3 SET_TO -1;
	      IFF(find_three_box_3_3_2(box, place, row1, col1, &row2, &row3,
				       &col2, &col3, &digi1, &digi2, &digi3,
				       world));
	      if (digi3 ISNT -1)
		{
		  IFF(reduce_box_three(box, row1, row2, row3, col1, col2,
				       col3, digi1, digi2, digi3, world));
		}
	      if (world->progress)
		break;
	      digi3 SET_TO -1;
	      IFF(find_three_box_3_2_2(box, row1, col1, &row2, &row3, &col2,
				       &col3, &digi1, &digi2, &digi3, world));
	      if (digi3 ISNT -1)
		{
		  IFF(reduce_box_three(box, row1, row2, row3, col1, col2,
				       col3, digi1, digi2, digi3, world));
		}
	      if (world->progress)
		break;
	    }
	  else if (world->sizes[row1][col1] IS 2)
	    {
	      digi3 SET_TO -1;
	      IFF(find_three_box_2_2_2(box, place, row1, col1, &row2, &row3,
				       &col2, &col3, &digi1, &digi2, &digi3,
				       world));
	      if (digi3 ISNT -1)
		{
		  IFF(reduce_box_three(box, row1, row2, row3, col1, col2,
				       col3, digi1, digi2, digi3, world));
		}
	      if (world->progress)
		break;
	    }
	}
      if (world->progress)
	break;
    }
  if (world->progress)
    {
      sprintf(message, "In box %d, only digits %d %d and %d fit "
	      "in [%d,%d], [%d,%d] and [%d,%d].\n"
	      "  Remove those digits elsewhere in the box.", (box + 1),
	      (digi1 + 1), (digi2 + 1), (digi3 + 1), (row1 + 1), (col1 + 1),
	      (row2 + 1), (col2 + 1), (row3 + 1), (col3 + 1));
      IFF(record_progress(message, world));
    }
  return OK;
}

/*************************************************************************/

/* try_box_two

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. record_progress returns ERROR.
  2. 

Called By:  solve_problem

Side Effects: If there are two squares in a box, each of which has
 only two choices, and the choices are the same, then those choices
 are removed from other squares in the box.

example (from sadmannakedpair1.pro):
Digits 8 and 9 must be in the last column, so the (148) is reduced to (14),
and the (149) is reduced to (14).

  |  5   (148)  (89)|
  |(149)   3    (89)|
  |  2     7     6  |

*/

int try_box_two(              /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_box_two";
  int box;
  int row1;
  int row2;
  int row3;
  int col1;
  int col2;
  int col3;
  int digi1;
  int digi2;
  int place1;
  int place2;
  int place3;
  char message[TEXT_SIZE];

  for (box SET_TO 0; ((box < 9) AND (NOT world->progress)); box++)
    {
      for (place1 SET_TO 0; ((place1 < 9) AND (NOT world->progress)); place1++)
	{
	  IFF(find_box_row_col(box, place1, &row1, &col1));
	  if (world->sizes[row1][col1] IS 2)
	    {
	      for (place2 SET_TO (place1 + 1);
		   ((place2 < 9) AND (NOT world->progress));
		   place2++)
		{
		  IFF(find_box_row_col(box, place2, &row2, &col2));
		  if ((world->sizes[row2][col2] ISNT 2) OR
		      (NOT choices_same(world->choices[row1][col1],
					world->choices[row2][col2])))
		    continue;
		  IFF(find_two_digits(world->choices[row1][col1],
				       &digi1, &digi2));
		  for (place3 SET_TO 0; place3 < 9; place3++)
		    {
		      IFF(find_box_row_col(box, place3, &row3, &col3));
		      if ((NOT ((row3 IS row1) AND (col3 IS col1))) AND
			  (NOT ((row3 IS row2) AND (col3 IS col2))))
			{
			  IFF(reduce_one(row3, col3, digi1, NULL, 0, world));
			  IFF(reduce_one(row3, col3, digi2, NULL, 0, world));
			}
		    }
		}
	    }
	}
    }
  if (world->progress)
    {
      sprintf(message, 
	      "In box %d, only digits %d and %d fit in [%d,%d] and [%d,%d].\n"
	      "  Remove %d and %d from choices for other squares in that box.",
	      (box + 1), (digi1 + 1), (digi2 + 1), (row1 + 1), (col1 + 1),
	      (row2 + 1), (col2 + 1), (digi1 + 1), (digi2 + 1));
      IFF(record_progress(message, world));
    }
  return OK;
}

/*************************************************************************/

/* try_chain

Returned Value: int

Called By: solve_problem

For increasing numbers of rounds of development from 2 to 4, for each
square in which there are exactly two choices, this makes a separate
environment for each of the two choices, develops each environment for
the given number of rounds, and analyzes the results to see if
anything can be concluded. If progress is made at any point, this
returns.

There is no point in analyzing results after one round, because no
progress is possible in only one round. It may be useful to try
more than 4 rounds.

This is duplicating work in getting to more rounds, but we want to
stop when the shortest possible chain is found. The alternative would
be to generate an array of pairs of environments and make multiple
passes through the array, running run each pair through a round on
each pass. That would take a lot more code.

*/

int try_chain(                /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_chain";
  int rounds;
  int row;
  int col;

  for (rounds SET_TO 2; ((rounds < 5) AND (NOT world->progress)); rounds++)
    {
      for (row SET_TO 0; ((row < 9) AND (NOT world->progress)); row++)
	{
	  for (col SET_TO 0; ((col < 9) AND (NOT world->progress)); col++)
	    {
	      if (world->sizes[row][col] IS 2)
		{
		  IFF(try_chain_from(row, col, rounds, world));
		}
	    }
	}
    }
  return OK;
}

/*************************************************************************/

/* try_chain_from

Returned Value: int
  If any of the following errors occurs, this returns ERROR.
  Otherwise it returns OK.
  1. find_two_digits returns ERROR.

Called By: try_chain

Side Effects:

This starts at a row and column in which there are exactly two
choices. It tries each of the choices in one of two separate
environments (env1 and env2) in which the world is modified in rounds. 

In each round, in both env1 and env2, for every square in which there
were multiple choices in the previous round but now there is only one
choice, that choice is deleted elsewhere in the row, column, and box
for that square. Also, for every row, column, and box in which there
is a digit that fits in only one square of it, all the other choices
in that square are removed. This leaves only one choice, which is
picked up on the next round by the preceding check.

After the given number of rounds are finished, if there are
corresponding (same row and column) squares in env1 and env2 in which
there is only one choice, and the choices are the same in env1 and
env2, then that square is so marked in the puzzle model. If there are
one or more such squares, the function returns as soon as it finds one.

*/

int try_chain_from(           /* ARGUMENTS               */
 int row,                     /* row with two choices    */
 int col,                     /* column with two choices */
 int rounds,                  /* number of rounds to run */
 struct sudoku_world * world) /* world model             */
{
  const char * name SET_TO "try_chain_from";
  int choices1[9][9][9];
  int choices2[9][9][9];
  int sizes1[9][9];
  int sizes2[9][9];
  int candidates[9][9];    // squares that may be changed
  int i;                   // index for rows
  int j;                   // index for columns
  int k;                   // index for digits
  int n;                   // index for rounds then choices
  int row_factor;          // factor for marking removed choices
  int digi1;               // choice for env1
  int digi2;               // choice for env2
  char message[TEXT_SIZE]; // buffer for progress message

  for (i SET_TO 0; i < 9; i++)
    {
      for (j SET_TO 0; j < 9; j++)
	{
	  sizes1[i][j] SET_TO world->sizes[i][j];
	  sizes2[i][j] SET_TO world->sizes[i][j];
	  candidates[i][j] SET_TO ((world->sizes[i][j] IS 10) ? 0 : 1);
	  for (k SET_TO 0; k < 9; k++)
	    {
	      choices1[i][j][k] SET_TO world->choices[i][j][k];
	      choices2[i][j][k] SET_TO world->choices[i][j][k];
	    }
	}
    }
  IFF(find_two_digits(world->choices[row][col], &digi1, &digi2));
  choices1[row][col][digi2] SET_TO 0;
  choices2[row][col][digi1] SET_TO 0;
  sizes1[row][col] SET_TO 1;
  sizes2[row][col] SET_TO 1;
  row_factor SET_TO 100;
  for (n SET_TO 0; n < rounds; n++)
    {
      run_round(choices1, sizes1, row_factor, world);
      run_round(choices2, sizes2, row_factor, world);
      row_factor SET_TO (row_factor * 100);
    }
  for (i SET_TO 0; ((i < 9) AND (NOT world->progress)); i++)
    {
      for (j SET_TO 0; ((j < 9) AND (NOT world->progress)); j++)
	{
	  if (candidates[i][j] AND
	      (sizes1[i][j] IS 10) AND (sizes2[i][j] IS 10))
	    {
	      for (k SET_TO 0; k < 9; k++)
		{
		  if ((choices1[i][j][k] IS 1) AND (choices2[i][j][k] IS 1))
		    {
		      if (world->print_choices IS 0)
			{
			  world->print_choices SET_TO 1;
			  IFF(print_sudoku(world));
			}
		      world->squares[i][j] SET_TO ('1' + k);
		      for (n SET_TO 0; n < 9; n++)
			{
			  if ((n ISNT k) AND (world->choices[i][j][n] IS 1))
			    {
			      delete_choice(i, j, n, 0, world);
			    }
			}
		      world->sizes[i][j] SET_TO 10;
		      reduce_cols(i, j, k, world);
		      reduce_rows(i, j, k, world);
		      reduce_boxes(i, j, k, world);
		      world->undone--;
		      world->progress SET_TO 1;
		      sprintf(message, "Put %d at [%d,%d]; it is forced "
			      "by either choice at [%d,%d]", (k + 1),
			      (i + 1), (j + 1), (row + 1), (col + 1));
		      IFF(record_progress(message, world));
		    }
		}
	    }
	}
    }
  return OK;
}

/*************************************************************************/

/* try_col_one

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. record_progress returns ERROR.
  2. Column data indicates there is a digit that fits in only one square
     of a column, but choices data indicates the digit fits in no
     square of the column: "Bug found during call to try_col_one".
  3. The number of places a digit can fit in a column is less than 1.
     "Puzzle has no answer."

Called By:  solve_problem

Side Effects: This tries to put a digit in one column if there is only one
square in that column in which the digit fits. As soon as it finds one it
puts the digit in the square, records progress, updates the world
model, and quits.

The progress message is of the form:
"Put 5 at [2,3]; it fits nowhere else in that column."

*/

int try_col_one(              /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_col_one";
  int row;
  int col;
  int digi;
  int k;
  char message[TEXT_SIZE];

  row SET_TO -1;
  for (col SET_TO 0; col < 9; col++)
    {
      for (digi SET_TO 0; digi < 9; digi++)
	{
	  if (world->cols[col][digi] IS 1)
	    {
	      for (row SET_TO 0; row < 9; row++)
		{
		  if (world->choices[row][col][digi] IS 1)
		    {
		      break;
		    }
		}
	      CHB((row IS 9), "Bug found during call to try_col_one");
	      world->squares[row][col] SET_TO ('1' + digi);
	      world->sizes[row][col] SET_TO 10;
	      world->cols[col][digi] SET_TO 10;
	      for (k SET_TO 0; k < 9; k++)
		{
		  if ((k ISNT digi) AND (world->choices[row][col][k] IS 1))
		    {
		      delete_choice(row, col, k, 0, world);
		    }
		}
	      reduce_cols(row, col, digi, world);
	      reduce_boxes(row, col, digi, world);
	      world->undone--;
	      world->progress SET_TO 1;
	      sprintf(message, "Put %d at [%d,%d]; "
		      "it fits nowhere else in that column.",
		      (digi + 1), (row + 1), (col + 1));
	      IFF(record_progress(message, world));
	      break;
	    }
	  else if (world->cols[col][digi] < 1)
	    CHB((col IS 9), "Puzzle has no answer");
	}
      if (row ISNT -1)
	break;
    }
  return OK;
}

/*************************************************************************/

/* try_col_same_box

Returned Value: int

Called By: solve_problem

Side Effects: If a given digit fits two or three places in a column,
and those two or three places are in the same box, then that digit
is removed from other columns in the box.

*/

int try_col_same_box(         /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_col_same_box";
  int col1;         /* main index for columns      */
  int col2;         /* secondary index for columns */
  int digi;        /* index for digits            */
  int box;          /* box identifier              */
  int row1;         /* first row identifier        */
  int row2;         /* second row identifier       */
  int row3;         /* third  row identifier       */
  int row4;         /* index for rows              */
  int place;        /* index for box               */
  int k;            /* index for message           */
  char message[TEXT_SIZE];

  for (col1 SET_TO 0; ((col1 < 9) AND (NOT world->progress)); col1++)
    {
      for (digi SET_TO 0; ((digi < 9) AND (NOT world->progress)); digi++)
	{
	  if ((world->cols[col1][digi] IS 2) OR
	      (world->cols[col1][digi] IS 3))
	    {
	      IFF(find_digit_in_col(col1, digi, 1, &row1, world));
	      IFF(find_digit_in_col(col1, digi, 2, &row2, world));
	      if (world->cols[col1][digi] IS 3)
		IFF(find_digit_in_col(col1, digi, 3, &row3, world));
	      else
		row3 SET_TO row1;
	      if ((boxFor(row1, col1) IS boxFor(row2, col1)) AND
		  (boxFor(row1, col1) IS boxFor(row3, col1)))
		{
		  box SET_TO boxFor(row1, col1);
		  for (place SET_TO 0; place < 9; place++)
		    {
		      IFF(find_box_row_col(box, place, &row4, &col2));
		      if (col2 ISNT col1)
			{
			  IFF(reduce_one(row4, col2, digi, NULL, 0, world));
			}
		    }
		  if (world->progress)
		    {
		      k SET_TO sprintf(message, "In column %d, digit %d fits "
				       "only in box %d, rows %d ", (col1 + 1),
				       (digi + 1), (box + 1), (row1 + 1));
		      if (world->cols[col1][digi] IS 2)
			{
			  k SET_TO (k + sprintf((message + k), "and %d.\n",
						(row2 + 1)));
			}
		      else  // if (world->cols[col1][digi] IS 3)
			{
			  k SET_TO (k + sprintf((message + k), "%d and %d.\n",
						(row2 + 1), (row3 + 1)));
			}
		      sprintf((message + k), "  Remove %d from choices in "
			      "other columns of box %d.",
			      (digi + 1), (box + 1));
		      IFF(record_progress(message, world));
		    }
		}
	    }
	}
    }
  return OK;
}

/*************************************************************************/

/* try_col_three

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. record_progress returns ERROR.
  2. 

Called By:  solve_problem

Side Effects: 

*/

int try_col_three(            /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_col_three";
  int col;
  int row1;
  int row2;
  int row3;
  int digi1;
  int digi2;
  int digi3;
  int j;            /* utility index                     */
  int k;            /* message index                     */
  int reduced[9];   /* columns that have choices reduced */
  char message[TEXT_SIZE];

  for (j SET_TO 0; j < 9; j++)
    reduced[j] SET_TO 0;
  for (col SET_TO 0; col < 9; col++)
    {
      for (row1 SET_TO 0; row1 < 9; row1++)
	{
	  if (world->sizes[row1][col] IS 3)
	    {
	      digi3 SET_TO -1;
	      IFF(find_three_col_3_3_3(col, row1, &row2, &row3,
				       &digi1, &digi2, &digi3, world));
	      if (digi3 ISNT -1)
		{
		  IFF(reduce_col_three(col, row1, row2, row3, digi1, digi2,
				       digi3, reduced, world));
		}
	      if (world->progress)
		break;
	      digi3 SET_TO -1;
	      IFF(find_three_col_3_3_2(col, row1, &row2, &row3,
				       &digi1, &digi2, &digi3, world));
	      if (digi3 ISNT -1)
		{
		  IFF(reduce_col_three(col, row1, row2, row3, digi1, digi2,
				       digi3, reduced, world));
		}
	      if (world->progress)
		break;
	      digi3 SET_TO -1;
	      IFF(find_three_col_3_2_2(col, row1, &row2, &row3,
				       &digi1, &digi2, &digi3, world));
	      if (digi3 ISNT -1)
		{
		  IFF(reduce_col_three(col, row1, row2, row3, digi1, digi2,
				       digi3, reduced, world));
		}
	      if (world->progress)
		break;
	    }
	  else if (world->sizes[row1][col] IS 2)
	    {
	      digi3 SET_TO -1;
	      IFF(find_three_col_2_2_2(col, row1, &row2, &row3,
				       &digi1, &digi2, &digi3, world));
	      if (digi3 ISNT -1)
		{
		  IFF(reduce_col_three(col, row1, row2, row3, digi1, digi2,
				       digi3, reduced, world));
		}
	      if (world->progress)
		break;
	    }
	}
      if (world->progress)
	break;
    }
  if (world->progress)
    {
      k SET_TO sprintf(message, 
		       "In column %d, only digits %d %d and %d fit "
		       "in rows %d %d and %d.\n"
		       "  Remove those digits from the choices in rows",
		       (col + 1), (digi1 + 1), (digi2 + 1),
		       (digi3 + 1), (row1 + 1), (row2 + 1), (row3 + 1));
      for (j SET_TO 0; j < 9; j++)
	{
	  if (reduced[j])
	    {
	      message[k++] SET_TO (' ');
	      message[k++] SET_TO ('1' + j);
	    }
	}
      message[k++] SET_TO '.';
      message[k] SET_TO 0;
      IFF(record_progress(message, world));
    }
  return OK;
}

/*************************************************************************/

/* try_col_two

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. record_progress returns ERROR.
  2. 

Called By:  solve_problem

Side Effects: 

*/

int try_col_two(              /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_col_two";
  int col;
  int row1;
  int row2;
  int digi1;
  int digi2;
  int j;            /* utility index                     */
  int k;            /* message index                     */
  int reduced[9];   /* rows that have choices reduced */
  char message[TEXT_SIZE];

  for (col SET_TO 0; col < 9; col++)
    {
      for (row1 SET_TO 0; row1 < 9; row1++)
	{
	  if (world->sizes[row1][col] ISNT 2)
	    continue;
	  for (row2 SET_TO (row1 + 1); row2 < 9; row2++)
	    {
	      if ((world->sizes[row2][col] ISNT 2) OR
		  (NOT choices_same(world->choices[row1][col],
				    world->choices[row2][col])))
		continue;
	      IFF(find_two_digits(world->choices[row1][col],
				   &digi1, &digi2));
	      for (j SET_TO 0; j < 9; j++)
		reduced[j] SET_TO 0;
	      for (j SET_TO 0; j < 9; j++)
		{
		  if ((j ISNT row1) AND (j ISNT row2))
		    {
		      IFF(reduce_one(j, col, digi1, reduced, 1, world));
		      IFF(reduce_one(j, col, digi2, reduced, 1, world));
		    }
		}
	      if (world->progress)
		break;
	    }
	  if (world->progress)
	    break;
	}
      if (world->progress)
	{
	  k SET_TO sprintf(message, 
			   "In column %d, only digits %d and %d fit "
			   "in rows %d and %d.\n"
			   "  Remove those digits from the choices in rows",
			   (col + 1), (digi1 + 1), (digi2 + 1),
			   (row1 + 1), (row2 + 1));
	  for (j SET_TO 0; j < 9; j++)
	    {
	      if (reduced[j])
		{
		  message[k++] SET_TO (' ');
		  message[k++] SET_TO ('1' + j);
		}
	    }
	  message[k++] SET_TO '.';
	  message[k] SET_TO 0;
	  IFF(record_progress(message, world));
	  break;
	}
    }
  return OK;
}

/*************************************************************************/

/* try_col_Xwing

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. record_progress returns ERROR.
  2. 

Called By:  solve_problem

Side Effects: 

*/

int try_col_Xwing(            /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_col_Xwing";
  int digi;
  int col;
  int col1;
  int col2;
  int row1;
  int row2;
  char message[TEXT_SIZE];

  for (digi SET_TO 0; ((digi < 9) AND (NOT world->progress)); digi++)
    {
      for (col1 SET_TO 0; ((col1 < 8) AND (NOT world->progress)); col1++)
	{
	  if (world->cols[col1][digi] ISNT 2)
	    continue;
	  IFF(find_digit_in_col(col1, digi, 1, &row1, world));
	  IFF(find_digit_in_col(col1, digi, 2, &row2, world));
	  for (col2 SET_TO (col1 + 1); col2 < 9; col2++)
	    {
	      if ((world->cols[col2][digi] IS 2) AND 
		  (world->choices[row1][col2][digi]) AND
		  (world->choices[row2][col2][digi]))
		{
		  for (col SET_TO 0; col < 9; col++)
		    {
		      if ((col ISNT col1) AND (col ISNT col2))
			{
			  if (world->choices[row1][col][digi])
			    {
			      IFF(reduce_one(row1, col, digi, NULL, 0, world));
			    }
			  if (world->choices[row2][col][digi])
			    {
			      IFF(reduce_one(row2, col, digi, NULL, 0, world));
			    }
			}
		    }
		  if (world->progress)
		    {
		      sprintf(message, "In columns %d and %d, %d fits only "
			      "in rows %d and %d.\n  Remove %d from "
                              "the choices for other columns in those rows.",
			      (col1 + 1), (col2 + 1), (digi + 1), 
			      (row1 + 1), (row2 + 1), (digi + 1));
		      IFF(record_progress(message, world));
		      break;
		    }
		}
	    }
	}
    }
  return OK;
}

/*************************************************************************/

/* try_no_choice

Returned Value: int

Called By: solve_problem

For increasing numbers of rounds of development from 2 to 4, for each
square in which there are exactly two choices, this makes a separate
environment for each of the two choices, develops each environment for
the given number of rounds, and checks each environment to see if any
square has no choices in either environment. If one environment has
such a square, the choice for that one must be incorrect. If the same
square in the other environment also has no choices, the puzzle has no
solution. Otherwise, the choice for the other environment must be
correct if there is any solution, so it is used in the puzzle model.

If progress is made at any point, this returns.

There is no point in analyzing results after one round, because no
progress is possible in only one round. It may be useful to try
more than 4 rounds.

This is duplicating work in getting to more rounds, but we want to
stop when the shortest possible chain is found. The alternative would
be to generate an array of pairs of environments and make multiple
passes through the array, running run each pair through a round on
each pass. That would take a lot more code.

*/

int try_no_choice(            /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_no_choice";
  int rounds;
  int row;
  int col;

  for (rounds SET_TO 2; ((rounds < 5) AND (NOT world->progress)); rounds++)
    {
      for (row SET_TO 0; ((row < 9) AND (NOT world->progress)); row++)
	{
	  for (col SET_TO 0; ((col < 9) AND (NOT world->progress)); col++)
	    {
	      if (world->sizes[row][col] IS 2)
		{
		  IFF(try_no_choice_from(row, col, rounds, world));
		}
	    }
	}
    }
  return OK;
}

/*************************************************************************/

/* try_no_choice_from

Returned Value: int

Called By: try_no_choice

This is using choices2 only to check that at least one of the two
choices does not lead to a contradiction. It is not clear that this
is necessary, since the puzzle will become insoluble later if a
choice leading to a contradiction is made now.

FIX - Remove choices2 here and put a check for puzzle consistency
at the beginning of each pass in solve_problem.

*/

int try_no_choice_from(       /* ARGUMENTS               */
 int row,                     /* row with two choices    */
 int col,                     /* column with two choices */
 int rounds,                  /* number of rounds to run */
 struct sudoku_world * world) /* world model             */
{
  const char * name SET_TO "try_no_choice_from";
  int choices1[9][9][9];
  int choices2[9][9][9];
  int sizes1[9][9];
  int sizes2[9][9];
  int i;                   // index for rows
  int j;                   // index for columns
  int k;                   // index for digits
  int n;                   // index for rounds
  int row_factor;          // factor for marking removed choices
  int digi1;               // choice for env1
  int digi2;               // choice for env2
  int digiNo;              // digi1 or digi2, whichever does not work
  char message[TEXT_SIZE]; // buffer for progress message

  for (i SET_TO 0; i < 9; i++)
    {
      for (j SET_TO 0; j < 9; j++)
	{
	  sizes1[i][j] SET_TO world->sizes[i][j];
	  sizes2[i][j] SET_TO world->sizes[i][j];
	  for (k SET_TO 0; k < 9; k++)
	    {
	      choices1[i][j][k] SET_TO world->choices[i][j][k];
	      choices2[i][j][k] SET_TO world->choices[i][j][k];
	    }
	}
    }
  IFF(find_two_digits(world->choices[row][col], &digi1, &digi2));
  choices1[row][col][digi2] SET_TO 0;
  choices2[row][col][digi1] SET_TO 0;
  sizes1[row][col] SET_TO 1;
  sizes2[row][col] SET_TO 1;
  row_factor SET_TO 100;
  for (n SET_TO 0; n < rounds; n++)
    {
      run_round(choices1, sizes1, row_factor, world);
      run_round(choices2, sizes2, row_factor, world);
      row_factor SET_TO (row_factor * 100);
    }
  for (i SET_TO 0; ((i < 9) AND (NOT world->progress)); i++)
    {
      for (j SET_TO 0; ((j < 9) AND (NOT world->progress)); j++)
	{
	  if ((sizes1[i][j] IS 0) OR (sizes2[i][j] IS 0))
	    {
	      CHB(((sizes1[i][j] IS 0) AND (sizes2[i][j] IS 0)),
		  "Puzzle has no answer");
	      if (sizes1[i][j] IS 0)
		{
		  digiNo SET_TO digi1;
		}
	      else // if (sizes2[i][j] IS 0)
		{
		  digiNo SET_TO digi2;
		}
	      IFF(reduce_one(row, col, digiNo, NULL, 0, world));
	      sprintf(message, 
		      "If %d were at [%d,%d], no digit would fit at [%d,%d].\n"
		      "  Remove %d from the choices at [%d,%d].",
		      (digiNo + 1), (row + 1), (col + 1), (i + 1), (j + 1),
		      (digiNo + 1), (row + 1), (col + 1));
	      IFF(record_progress(message, world));
	    }
	}
    }
  return OK;
}

/*************************************************************************/

/* try_row_one

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. record_progress returns ERROR.
  2. Row data indicates there is a digit that fits in only one square
     of a row, but choices data indicates the digit fits in no
     square of the row: "Bug found during call to try_row_one".
  3. The number of places a digit can fit in a row is less than 1.
     "Puzzle has no answer."

Called By:  solve_problem

Side Effects: This tries to put a digit in one row if there is only one
square in that row in which the digit fits. As soon as it finds one it
puts the digit in the square, records progress, updates the world
model, and quits.

The progress message is of the form:
"Put 5 at [2,3]; it fits nowhere else in that row."

*/

int try_row_one(              /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_row_one";
  int row;
  int col;
  int digi;
  int k;
  char message[TEXT_SIZE];

  col SET_TO -1;
  for (row SET_TO 0; row < 9; row++)
    {
      for (digi SET_TO 0; digi < 9; digi++)
	{
	  if (world->rows[row][digi] IS 1)
	    {
	      for (col SET_TO 0; col < 9; col++)
		{
		  if (world->choices[row][col][digi] IS 1)
		    {
		      break;
		    }
		}
	      CHB((col IS 9), "Bug found during call to try_row_one");
	      world->squares[row][col] SET_TO ('1' + digi);
	      world->sizes[row][col] SET_TO 10;
	      world->rows[row][digi] SET_TO 10;
	      for (k SET_TO 0; k < 9; k++)
		{
		  if ((k ISNT digi) AND (world->choices[row][col][k] IS 1))
		    {
		      delete_choice(row, col, k, 0, world);
		    }
		}
	      reduce_rows(row, col, digi, world);
	      reduce_boxes(row, col, digi, world);
	      world->undone--;
	      world->progress SET_TO 1;
	      sprintf(message, "Put %d at [%d,%d]; "
		      "it fits nowhere else in that row.",
		      (digi + 1), (row + 1), (col + 1));
	      IFF(record_progress(message, world));
	      break;
	    }
	  else if (world->rows[row][digi] < 1)
	    CHB((col IS 9), "Puzzle has no answer.");
	}
      if (col ISNT -1)
	break;
    }
  return OK;
}

/*************************************************************************/

/* try_row_same_box

If a given digit fits only two or three places in a row, and those two
or three places are in the same box, then that digit cannot go
elsewhere in the box.

For example, in the following, 2 can be eliminated on the second and
third rows in the box on the far right.

---------------------------------------------------------
|  6     (37)    5  |  9    1   4  | (27)    8    (237) |
|(1248) (1347) (18) |(237)  5 (237)|  9    (126)  (2367)|
| (12)  (137)    9  |(237)  6   8  |(1257) (125)    4   |
---------------------------------------------------------


*/

int try_row_same_box(         /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_row_same_box";
  int row1;         /* main index for rows      */
  int row2;         /* secondary index for rows */
  int digi;        /* index for digits         */
  int box;          /* box identifier           */
  int col1;         /* first column identifier  */
  int col2;         /* second column identifier */
  int col3;         /* third column identifier  */
  int col4;         /* index for columns        */
  int place;        /* index for box            */
  int k;            /* index for message        */
  char message[TEXT_SIZE];

  for (row1 SET_TO 0; ((row1 < 9) AND (NOT world->progress)); row1++)
    {
      for (digi SET_TO 0; ((digi < 9) AND (NOT world->progress)); digi++)
	{
	  if ((world->rows[row1][digi] IS 2) OR
	      (world->rows[row1][digi] IS 3))
	    {
	      IFF(find_digit_in_row(row1, digi, 1, &col1, world));
	      IFF(find_digit_in_row(row1, digi, 2, &col2, world));
	      if (world->rows[row1][digi] IS 3)
		IFF(find_digit_in_row(row1, digi, 3, &col3, world));
	      else
		col3 SET_TO col1;
	      if ((boxFor(row1, col1) IS boxFor(row1, col2)) AND
		  (boxFor(row1, col1) IS boxFor(row1, col3)))
		{
		  box SET_TO boxFor(row1, col1);
		  for (place SET_TO 0; place < 9; place++)
		    {
		      IFF(find_box_row_col(box, place, &row2, &col4));
		      if (row2 ISNT row1)
			{
			  IFF(reduce_one(row2, col4, digi, NULL, 0, world));
			}
		    }
		  if (world->progress)
		    {
		      k SET_TO sprintf(message, "In row %d, digit %d fits only "
				       "in box %d, columns %d ", (row1 + 1),
				       (digi + 1), (box + 1), (col1 + 1));
		      if (world->rows[row1][digi] IS 2)
			{
			  k SET_TO (k + sprintf((message + k), "and %d.\n",
						(col2 + 1)));
			}
		      else //(world->rows[row1][digi] IS 3)
			{
			  k SET_TO (k + sprintf((message + k), "%d and %d.\n",
						(col2 + 1), (col3 + 1)));
			}
		      sprintf((message + k), "  Remove %d from choices in "
			      "other rows of box %d.", (digi + 1), (box + 1));
		      IFF(record_progress(message, world));
		    }
		}
	    }
	}
    }
  return OK;
}

/*************************************************************************/

/* try_row_three

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. record_progress returns ERROR.
  2. 

Called By:  solve_problem

Side Effects: 

If there are three columns in a row in which two or three of the same
three digits fit, those three columns must use those digits, so the
digits may be removed from the choices for other columns in that row.

Example
------------------------------------------------------------
|   5       7      (34) | 9    2    8  |  6     1     (34) |
| (469)   (469)     8   | 3    1   (46)|(279) (2579) (2459)|
|   1     (3469)    2   | 5    7   (46)|  8    (39)  (349) |
------------------------------------------------------------

In row 2, only digits 4 6 and 9 fit in columns 1 2 and 6.
  Remove those digits from the choices in columns 7 8 9.

*/

int try_row_three(            /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_row_three";
  int row;
  int col1;
  int col2;
  int col3;
  int digi1;
  int digi2;
  int digi3;
  int j;            /* utility index                     */
  int k;            /* message index                     */
  int reduced[9];   /* columns that have choices reduced */
  char message[TEXT_SIZE];

  for (j SET_TO 0; j < 9; j++)
    reduced[j] SET_TO 0;
  for (row SET_TO 0; row < 9; row++)
    {
      for (col1 SET_TO 0; col1 < 9; col1++)
	{
	  if (world->sizes[row][col1] IS 3)
	    {
	      digi3 SET_TO -1;
	      IFF(find_three_row_3_3_3(row, col1, &col2, &col3,
				       &digi1, &digi2, &digi3, world));
	      if (digi3 ISNT -1)
		{
		  IFF(reduce_row_three(row, col1, col2, col3, digi1, digi2,
				       digi3, reduced, world));
		}
	      if (world->progress)
		break;
	      digi3 SET_TO -1;
	      IFF(find_three_row_3_3_2(row, col1, &col2, &col3,
				       &digi1, &digi2, &digi3, world));
	      if (digi3 ISNT -1)
		{
		  IFF(reduce_row_three(row, col1, col2, col3, digi1, digi2,
				       digi3, reduced, world));
		}
	      if (world->progress)
		break;
	      digi3 SET_TO -1;
	      IFF(find_three_row_3_2_2(row, col1, &col2, &col3,
				       &digi1, &digi2, &digi3, world));
	      if (digi3 ISNT -1)
		{
		  IFF(reduce_row_three(row, col1, col2, col3, digi1, digi2,
				       digi3, reduced, world));
		}
	      if (world->progress)
		break;
	    }
	  else if (world->sizes[row][col1] IS 2)
	    {
	      digi3 SET_TO -1;
	      IFF(find_three_row_2_2_2(row, col1, &col2, &col3,
				       &digi1, &digi2, &digi3, world));
	      if (digi3 ISNT -1)
		{
		  IFF(reduce_row_three(row, col1, col2, col3, digi1, digi2,
				       digi3, reduced, world));
		}
	      if (world->progress)
		break;
	    }
	}
      if (world->progress)
	break;
    }
  if (world->progress)
    {
      k SET_TO sprintf(message, 
		       "In row %d, only digits %d %d and %d fit "
		       "in columns %d %d and %d.\n"
		       "  Remove those digits from the choices in columns",
		       (row + 1), (digi1 + 1), (digi2 + 1),
		       (digi3 + 1), (col1 + 1), (col2 + 1), (col3 + 1));
      for (j SET_TO 0; j < 9; j++)
	{
	  if (reduced[j])
	    {
	      message[k++] SET_TO (' ');
	      message[k++] SET_TO ('1' + j);
	    }
	}
      message[k++] SET_TO '.';
      message[k] SET_TO 0;
      IFF(record_progress(message, world));
    }
  return OK;
}

/*************************************************************************/

/* try_row_two

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. record_progress returns ERROR.
  2. 

Called By:  solve_problem

Side Effects: 

If there are two columns in a row in which only the same two digits fit,
then they must go in those two columns, so they are removed from other
columns of the row.

example (from sadmannakedpair1.pro):
In the following row, (14) occurs in columns 4 and 8, so the (14689)
in column 7 is reduced to (689), and the (16) in column 3 is reduced
to (6).

 2  7 (16) (14) 3 (89) (14689) (14) 5  

*/

int try_row_two(              /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_row_two";
  int row;
  int col1;
  int col2;
  int digi1;
  int digi2;
  int j;            /* utility index                     */
  int k;            /* message index                     */
  int reduced[9];   /* columns that have choices reduced */
  char message[TEXT_SIZE];

  for (row SET_TO 0; row < 9; row++)
    {
      for (col1 SET_TO 0; col1 < 9; col1++)
	{
	  if (world->sizes[row][col1] ISNT 2)
	    continue;
	  for (col2 SET_TO (col1 + 1); col2 < 9; col2++)
	    {
	      if ((world->sizes[row][col2] ISNT 2) OR
		  (NOT choices_same(world->choices[row][col1],
				    world->choices[row][col2])))
		continue;
	      IFF(find_two_digits(world->choices[row][col1],
				   &digi1, &digi2));
	      for (j SET_TO 0; j < 9; j++)
		reduced[j] SET_TO 0;
	      for (j SET_TO 0; j < 9; j++)
		{
		  if ((j ISNT col1) AND (j ISNT col2))
		    {
		      IFF(reduce_one(row, j, digi1, reduced, 0, world));
		      IFF(reduce_one(row, j, digi2, reduced, 0, world));
		    }
		}
	      if (world->progress)
		break;
	    }
	  if (world->progress)
	    break;
	}
      if (world->progress)
	{
	  k SET_TO sprintf(message, 
			   "In row %d, only digits %d and %d fit "
			   "in columns %d and %d.\n"
			   "  Remove those digits from the choices in columns",
			   (row + 1), (digi1 + 1), (digi2 + 1),
			   (col1 + 1), (col2 + 1));
	  for (j SET_TO 0; j < 9; j++)
	    {
	      if (reduced[j])
		{
		  message[k++] SET_TO (' ');
		  message[k++] SET_TO ('1' + j);
		}
	    }
	  message[k++] SET_TO '.';
	  message[k] SET_TO 0;
	  IFF(record_progress(message, world));
	  break;
	}
    }
  return OK;
}

/*************************************************************************/

/* try_row_Xwing

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. record_progress returns ERROR.
  2. 

Called By:  solve_problem

Side Effects: 

Example (from sadmanxwing2.pro)
-----------------------------------------------------------
| (47)  (249)    1   | 8    5    3  |  6     (247)  (249) |
|  5    (369)  (789) | 2    4   (16)|(1789)  (378)   (19) |
|(3468) (2346)  (28) | 7    9   (16)| (18)  (23458) (1245)|
-----------------------------------------------------------
|  9      7      3   | 1    2    8  |  5     (46)    (46) |
|  2      8      5   | 9    6    4  |  3       1      7   |
| (16)   (16)    4   | 5    3    7  |  2       9      8   |
-----------------------------------------------------------
|(3478) (2349) (2789)|(46)  1    5  |(789)  (2678)  (269) |
|(1478) (1245) (278) |(46) (78)  9  |(178)  (25678)   3   |
|(178)  (159)    6   | 3   (78)  2  |  4     (578)  (159) |
-----------------------------------------------------------
In rows 1 and 9, digit 9 fits only in columns 2 and 9.
  Remove 9 from the choices for other rows in those columns.


*/

int try_row_Xwing(            /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_row_Xwing";
  int digi;
  int row;
  int row1;
  int row2;
  int col1;
  int col2;
  char message[TEXT_SIZE];

  for (digi SET_TO 0; ((digi < 9) AND (NOT world->progress)); digi++)
    {
      for (row1 SET_TO 0; ((row1 < 8) AND (NOT world->progress)); row1++)
	{
	  if (world->rows[row1][digi] ISNT 2)
	    continue;
	  IFF(find_digit_in_row(row1, digi, 1, &col1, world));
	  IFF(find_digit_in_row(row1, digi, 2, &col2, world));
	  for (row2 SET_TO (row1 + 1); row2 < 9; row2++)
	    {
	      if ((world->rows[row2][digi] IS 2) AND 
		  (world->choices[row2][col1][digi]) AND
		  (world->choices[row2][col2][digi]))
		{
		  for (row SET_TO 0; row < 9; row++)
		    {
		      if ((row ISNT row1) AND (row ISNT row2))
			{
			  if (world->choices[row][col1][digi])
			    {
			      IFF(reduce_one(row, col1, digi, NULL, 0, world));
			    }
			  if (world->choices[row][col2][digi])
			    {
			      IFF(reduce_one(row, col2, digi, NULL, 0, world));
			    }
			}
		    }
		  if (world->progress)
		    {
		      sprintf(message, "In rows %d and %d, digit %d fits only "
			      "in columns %d and %d.\n  Remove %d from "
                              "the choices for other rows in those columns.",
			      (row1 + 1), (row2 + 1), (digi + 1), 
			      (col1 + 1), (col2 + 1),(digi + 1));
		      IFF(record_progress(message, world));
		      break;
		    }
		}
	    }
	}
    }
  return OK;
}

/*************************************************************************/

/* try_square_one

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. record_progress returns ERROR.

Called By:  solve_problem

Side Effects: This tries to find a blank square in which only one digit will
fit. If it finds one, it puts the digit in the square, updates the
world model, and records a progress message.

The progress message is of the form:
"Put 2 at [9,4]; it's the only digit that fits."

*/

int try_square_one(           /* ARGUMENTS   */
 struct sudoku_world * world) /* world model */
{
  const char * name SET_TO "try_square_one";
  int row;
  int col;
  int digi;
  char digit;
  char message[TEXT_SIZE];

  for (row SET_TO 0; row < 9; row++)
    {
      for (col SET_TO 0; col < 9; col++)
	{
	  if (world->sizes[row][col] IS 1)
	    {
	      for (digi SET_TO 0; digi < 9; digi++)
		{
		  if (world->choices[row][col][digi] IS 1)
		    {
		      break;
		    }
		}
	      digit SET_TO ('1' + digi);
	      world->squares[row][col] SET_TO digit;
	      world->sizes[row][col] SET_TO 10;
              IFF(reduce_rows(row, col, digi, world));
	      IFF(reduce_cols(row, col, digi, world));
	      IFF(reduce_boxes(row, col, digi, world));
	      world->undone--;
	      world->progress SET_TO 1;
	      sprintf(message, "Put %d at [%d,%d]; "
		      "it's the only digit that fits.",
		      (digi + 1), (row + 1), (col + 1));
	      IFF(record_progress(message, world));
	      break;
	    }
	}
      if (col ISNT 9)
	{
	  break;
	}
    }
  return OK;
}

/*************************************************************************/

/* try_stack_digi

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. record_progress returns ERROR.
  

Called By: try_box_box_col

A tier is a row of boxes. A stack is a column of boxes.


*/
#define c world->choices

int try_stack_digi(           /* ARGUMENTS              */
 int stack,                   /* index of stack to test */
 int digi,                    /* index of digit to test */
 struct sudoku_world * world) /* world model            */
{
  const char * name SET_TO "try_stack_digi";
  int row1;
  int row2;
  int row3;
  int col1;
  int col2;
  int col3;
  int n;
  int tier;
  int col11;
  int col12;
  int col13;
  int col21;
  int col22;
  int col23;
  int col31;
  int col32;
  int col33;
  char message[TEXT_SIZE];

  for (n SET_TO 0; ((n < 3) AND (NOT world->progress)); n++)
    { // this loop swaps columns
      col1 SET_TO ((stack * 3) + n);
      col2 SET_TO ((stack * 3) + ((n + 1) % 3));
      col3 SET_TO ((stack * 3) + ((n + 2) % 3));
      for (tier SET_TO 0; ((tier < 3) AND (NOT world->progress)); tier++)
	{
	  row1 SET_TO (tier * 3);
	  row2 SET_TO (((tier * 3) + 3) % 9);
	  row3 SET_TO (((tier * 3) + 6) % 9);
	  col11 SET_TO (c[row1][col1][digi] OR c[row1+1][col1][digi] OR
			c[row1+2][col1][digi]);
	  col12 SET_TO (c[row2][col1][digi] OR c[row2+1][col1][digi] OR
			c[row2+2][col1][digi]);
	  col13 SET_TO (c[row3][col1][digi] OR c[row3+1][col1][digi] OR
			c[row3+2][col1][digi]);
	  col21 SET_TO (c[row1][col2][digi] OR c[row1+1][col2][digi] OR
			c[row1+2][col2][digi]);
	  col22 SET_TO (c[row2][col2][digi] OR c[row2+1][col2][digi] OR
			c[row2+2][col2][digi]);
	  col23 SET_TO (c[row3][col2][digi] OR c[row3+1][col2][digi] OR
			c[row3+2][col2][digi]);
	  col31 SET_TO (c[row1][col3][digi] OR c[row1+1][col3][digi] OR
			c[row1+2][col3][digi]);
	  col32 SET_TO (c[row2][col3][digi] OR c[row2+1][col3][digi] OR
			c[row2+2][col3][digi]);
	  col33 SET_TO (c[row3][col3][digi] OR c[row3+1][col3][digi] OR
			c[row3+2][col3][digi]);
	  if (col11 AND col12 AND col21 AND col22 AND
	      (NOT col31) AND (NOT col32))
	    {
	      if (col13 OR col23)
		{
		  if (c[row3][col1][digi])
		    IFF(reduce_one(row3, col1, digi, NULL, 0, world));
		  if (c[row3+1][col1][digi])
		    IFF(reduce_one((row3+1), col1, digi, NULL, 0, world));
		  if (c[row3+2][col1][digi])
		    IFF(reduce_one((row3+2), col1, digi, NULL, 0, world));
		  if (c[row3][col2][digi])
		    IFF(reduce_one(row3, col2, digi, NULL, 0, world));
		  if (c[row3+1][col2][digi])
		    IFF(reduce_one((row3+1), col2, digi, NULL, 0, world));
		  if (c[row3+2][col2][digi])
		    IFF(reduce_one((row3+2), col2, digi, NULL, 0, world));
		  CHB((NOT world->progress),
		      "Bug found during call to try_tier_stack");
		  sprintf(message, "In box %d and box %d, %d fits only in "
			  "columns %d and %d.\n  Remove %d where it appears in "
			  "those columns of box %d\n", (boxFor(row1, col1) + 1),
			  (boxFor(row2, col1) + 1), (digi + 1), (col1 + 1),
			  (col2 + 1), (digi + 1), (boxFor(row3, col1) + 1));
		  IFF(record_progress(message, world));
		}
	      else
		{
		  CHB((NOT col33), "Puzzle has no answer");
		}
	    }
	}
    }
  return OK;
}

/*************************************************************************/

/* try_tier_digi

Returned Value: int
  If any of the following errors occur, this returns ERROR.
  Otherwise, it returns OK.
  1. record_progress returns ERROR.
  

Called By: try_box_box_row

A tier is a row of boxes. A stack is a column of boxes.

*/

#define c1 world->choices[row1]
#define c2 world->choices[row2]
#define c3 world->choices[row3]

int try_tier_digi(            /* ARGUMENTS              */
 int tier,                    /* index of tier to test  */
 int digi,                    /* index of digit to test */
 struct sudoku_world * world) /* world model            */
{
  const char * name SET_TO "try_tier_digi";
  int row1;
  int row2;
  int row3;
  int col1;
  int col2;
  int col3;
  int n;
  int stack;
  int row11;
  int row12;
  int row13;
  int row21;
  int row22;
  int row23;
  int row31;
  int row32;
  int row33;
  char message[TEXT_SIZE];

  for (n SET_TO 0; ((n < 3) AND (NOT world->progress)); n++)
    { // this loop swaps rows
      row1 SET_TO ((tier * 3) + n);
      row2 SET_TO ((tier * 3) + ((n + 1) % 3));
      row3 SET_TO ((tier * 3) + ((n + 2) % 3));
      for (stack SET_TO 0; ((stack < 3) AND (NOT world->progress)); stack++)
	{
	  col1 SET_TO (stack * 3);
	  col2 SET_TO (((stack * 3) + 3) % 9);
	  col3 SET_TO (((stack * 3) + 6) % 9);
	  row11 SET_TO (c1[col1][digi] OR c1[col1+1][digi] OR c1[col1+2][digi]);
	  row12 SET_TO (c1[col2][digi] OR c1[col2+1][digi] OR c1[col2+2][digi]);
	  row13 SET_TO (c1[col3][digi] OR c1[col3+1][digi] OR c1[col3+2][digi]);
	  row21 SET_TO (c2[col1][digi] OR c2[col1+1][digi] OR c2[col1+2][digi]);
	  row22 SET_TO (c2[col2][digi] OR c2[col2+1][digi] OR c2[col2+2][digi]);
	  row23 SET_TO (c2[col3][digi] OR c2[col3+1][digi] OR c2[col3+2][digi]);
	  row31 SET_TO (c3[col1][digi] OR c3[col1+1][digi] OR c3[col1+2][digi]);
	  row32 SET_TO (c3[col2][digi] OR c3[col2+1][digi] OR c3[col2+2][digi]);
	  row33 SET_TO (c3[col3][digi] OR c3[col3+1][digi] OR c3[col3+2][digi]);
	  if (row11 AND row12 AND row21 AND row22 AND
	      (NOT row31) AND (NOT row32))
	    {
	      if (row13 OR row23)
		{
		  if (c1[col3][digi])
		    IFF(reduce_one(row1, col3, digi, NULL, 0, world));
		  if (c1[col3+1][digi])
		    IFF(reduce_one(row1, (col3+1), digi, NULL, 0, world));
		  if (c1[col3+2][digi])
		    IFF(reduce_one(row1, (col3+2), digi, NULL, 0, world));
		  if (c2[col3][digi])
		    IFF(reduce_one(row2, col3, digi, NULL, 0, world));
		  if (c2[col3+1][digi])
		    IFF(reduce_one(row2, (col3+1), digi, NULL, 0, world));
		  if (c2[col3+2][digi])
		    IFF(reduce_one(row2, (col3+2), digi, NULL, 0, world));
		  CHB((NOT world->progress),
		      "Bug found during call to try_tier_digi");
		  sprintf(message, "In box %d and box %d, %d fits only in "
			  "rows %d and %d.\n  Remove %d where it appears in "
			  "those rows of box %d\n", (boxFor(row1, col1) + 1),
			  (boxFor(row1, col2) + 1), (digi + 1), (row1 + 1),
			  (row2 + 1), (digi + 1), (boxFor(row1, col3) + 1));
		  IFF(record_progress(message, world));
		}
	      else
		{
		  CHB((NOT row33), "Puzzle has no answer");
		}
	    }
	}
    }
  return OK;
}

/*************************************************************************/

